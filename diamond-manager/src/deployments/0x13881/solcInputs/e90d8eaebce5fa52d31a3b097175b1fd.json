{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/common/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct RoleData {\n\tmapping(address => bool) members;\n\tbytes32 adminRole;\n}\n \n/// @title  A contract that administrate roles & access\n/// @notice You can use this contract to modify and define the role of an user\nabstract contract AccessControlEnumerable is Context {\t\n    /// @notice This event stores in the blockchain when an admin role changes\n    /// @param  role Contains the admin role that we want to use \n    /// @param  previousAdminRole Contains the previous admin role\n    /// @param  newAdminRole Contains the new admin role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when a role is granted\n    /// @param  role Contains the admin role that we want to use \n    /// @param  account Contains the account we want to add to a new role\n    /// @param  sender Contains the sender of the role petition\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    /// @notice This event stores in the blockchain when a role is revoked\n    /// @param  role Contains the admin role that we want to use \n    /// @param  account Contains the account we want to add to a new role\n    /// @param  sender Contains the sender of the role petition\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /// @notice Allow an user to quit an owned role\n    /// @notice The account that sends the petition needs to be the same that will renounce to a role\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use.    \n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    /// @notice Allow an admin to asign a new role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /// @notice Allow an admin to revoke a role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to verify \n    /// @param  account Contains the account address to check. \n    /// @return role in boolean, if the account has the selected role\n    function hasRole(bytes32 role, address account) public view virtual returns (bool);\n\n\t/// @notice Allow us to verify the branch of roles asociated to an father role\n    /// @param  role Contains the role that we want to verify\n    /// @return bytes32 with the child role\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32);\n\n    /// @notice Check if the account with the index has the desired role\n    /// @param  role Contains the role that we want to use \n    /// @param  index Contains the index asociated to an account\n    /// @return address of the account with the index position in the list of the desired role\n\tfunction getRoleMember(bytes32 role, uint256 index) public view virtual returns (address);\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to verify\n    /// @return uint256 wuth he total of members with the desired role \n\tfunction getRoleMemberCount(bytes32 role) public view virtual returns (uint256);\n\n    /// @param role Contains the role that we want to use \n    /// @param adminRole Contains the new admin role to use\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual;\n\n    /// @notice Grants a role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n\tfunction _grantRole(bytes32 role, address account) internal virtual;\n\n    /// @notice Revokes a role to an account \n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n\tfunction _revokeRole(bytes32 role, address account) internal virtual;\n}"
    },
    "contracts/common/DiamondStorage/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { AccessControlEnumerableStorage } from \"./AccessControlEnumerableStorage.sol\";\n\nabstract contract AccessControlEnumerable is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn AccessControlEnumerableStorage.layout()._roles[role].members[account];\n\t}\n\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn AccessControlEnumerableStorage.layout()._roles[role].adminRole;\n\t}\n\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn AccessControlEnumerableStorage.layout()._roleMembers[role].at(index);\n\t}\n\t\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn AccessControlEnumerableStorage.layout()._roleMembers[role].length();\n\t}\n\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\tAccessControlEnumerableStorage.layout()._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\tAccessControlEnumerableStorage.layout()._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\tAccessControlEnumerableStorage.layout()._roleMembers[role].add(account);\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\tAccessControlEnumerableStorage.layout()._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\tAccessControlEnumerableStorage.layout()._roleMembers[role].remove(account);\n\t\t}\n\t}\n}"
    },
    "contracts/common/DiamondStorage/AccessControlEnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary AccessControlEnumerableStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.AccessControlEnumerable');\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) _roles;\n        mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/diamondStandard/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/Factory/AccessControlRoles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nabstract contract FactoryHandlerRoles {\n\tbytes32 public constant WITHDRAW_SIGNER = keccak256(\"rair.factory.withdrawSystemSigner\");\n\tbytes32 public constant ADMINISTRATOR = keccak256(\"rair.factory.administrator\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n}"
    },
    "contracts/Factory/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary FactoryStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.DiamondFactory');\n\n    struct Layout {\n        address[] creators;\n\t\tmapping(address => address[]) creatorToContracts;\n\t\tmapping(address => address) contractToCreator;\n\t\tmapping(address => uint) deploymentCostForToken;\n        address currentERC20;\n        mapping(address => uint) currentUserPoints;\n        mapping(address => uint) totalUserPoints;\n        uint transferTimeLimit;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/Factory/facets/creatorsFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { AccessControlEnumerable } from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tOur Facet creators contract\n/// @notice You can use this contract to view the creator of contracts and the list of contractsdeployed\ncontract creatorFacet is AccessControlEnumerable {\n\t/// @notice Returns the number of addresses that have deployed a contract\n\t/// @return count with the total of creators of this contract\n\tfunction getCreatorsCount() public view returns(uint count) {\n\t\treturn FactoryStorage.layout().creators.length;\n\t}\n\n\t/// @notice Returns a single address inside the creators array\n\t/// @param \tindex number of the index for look inside our array\n\t/// @return creator \tAddress of the selected index\n\tfunction getCreatorAtIndex(uint index) public view returns (address creator) {\n\t\tcreator = FactoryStorage.layout().creators[index];\n\t}\n\n\t/// @notice Returns the number of contracts deployed by an address\n\t/// @dev\tUse alongside creatorToContracts for the full list of tokens \n\t/// @param\tdeployer\tWallet address to query\n\t/// @return count \tNumber of contracts deployed by the deployer\n\tfunction getContractCountOf(address deployer) public view returns(uint count) {\n\t\treturn FactoryStorage.layout().creatorToContracts[deployer].length;\n\t}\n\n\t/// @notice Necessary view function now that public mappings are not possible\n\t/// @param \tdeployer Contains the facet addresses and function selectors\n\t/// @param \tindex Contains the facet addresses and function selectors\n\t/// @return deployedContract \tAddress of the deployed ERC721\n\tfunction creatorToContractIndex(address deployer, uint index) public view returns(address deployedContract) {\n\t\treturn FactoryStorage.layout().creatorToContracts[deployer][index];\n\t}\n\n\t/// @notice Returns the whole array of deployed addresses of a creator\n\t/// @param \tdeployer Contains the facet addresses and function selectors\n\t/// @return deployedContracts \tAddresses of the deployed contracts  \n\tfunction creatorToContractList(address deployer) public view returns(address[] memory deployedContracts) {\n\t\treturn FactoryStorage.layout().creatorToContracts[deployer];\n\t}\n\n\t/// @notice Returns the address of the creator given a deployed contract's address\n\t/// @param \tdeployedContract Contains the facet addresses and function selectors\n\t/// @return creator \tAddress of the contracts creator\n\tfunction contractToCreator(address deployedContract) public view returns (address creator) {\n\t\tcreator = FactoryStorage.layout().contractToCreator[deployedContract];\n\t}\n}"
    },
    "contracts/Factory/facets/DeployerFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessControlEnumerable } from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { RAIR_ERC721_Diamond } from '../../tokens/RAIR-ERC721-Diamond.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tERC721 factory\n/// @notice\tFacet receives ERC777 tokens and deploys an ERC721 smart contract\ncontract DeployerFacet is AccessControlEnumerable {\n\t/// @notice This event stores in the blockchain when a new contract is deployed\n    /// @param\tdeployerAddress \tContains the address of the deployer of the contract \n    /// @param \tdeploymentIndex \tContains the corresponding ID for the deployment\n    /// @param \tdeploymentAddress \tContains the address where the contract was deployed\n\t/// @param \tdeploymentName \t\tContains the name of the deployed contract\n\tevent DeployedContract(\n\t\taddress deployerAddress,\n\t\tuint deploymentIndex,\n\t\taddress deploymentAddress,\n\t\tstring deploymentName\n\t);\n\n\tfunction deployContract(\n\t\tstring calldata contractName,\n\t\tstring calldata contractSymbol\n\t) external {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).allowance(msg.sender, address(this)) >= store.deploymentCostForToken[store.currentERC20],\n\t\t\t'Deployer: Not allowed to transfer tokens'\n\t\t);\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).transferFrom(msg.sender, address(this), store.deploymentCostForToken[store.currentERC20]),\n\t\t\t'Deployer: Error transferring tokens'\n\t\t);\n\n\t\taddress[] storage deploymentsFromOwner = store.creatorToContracts[msg.sender];\n\t\tstore.totalUserPoints[msg.sender] += store.deploymentCostForToken[store.currentERC20];\n\t\t\n\t\tif (deploymentsFromOwner.length == 0) {\n\t\t\tstore.creators.push(msg.sender);\n\t\t}\n\n\t\tRAIR_ERC721_Diamond newToken = new RAIR_ERC721_Diamond(contractName, contractSymbol, msg.sender, 30000);\n\t\tdeploymentsFromOwner.push(address(newToken));\n\t\tstore.contractToCreator[address(newToken)] = msg.sender;\n\t\temit DeployedContract(msg.sender, deploymentsFromOwner.length - 1, address(newToken), contractName);\n\t}\n}"
    },
    "contracts/Factory/facets/DepositLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { FactoryHandlerRoles } from '../AccessControlRoles.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tDeposit logic for the points system\n/// @notice Uses the ERC777 receiver hook to trigger additional logic\ncontract PointsDeposit is AccessControlEnumerable, FactoryHandlerRoles {\n    /// @notice This event stores the user that deposited tokens into the contract\n    /// @param\tuserAddress             Public address of the user depositing\n    /// @param \ttokenAddress            Address of the ERC777 contract used\n    /// @param \tamount                  Amount of tokens transferred to this contract\n\t/// @param \ttotalTokensDeposited    Total amount of tokens deposited by the user\n\tevent ReceivedTokens(address userAddress, address tokenAddress, uint amount, uint totalTokensDeposited);\n\n\t/// @notice Deposit tokens from the user's balance to this contract\n\t/// @param \tamount The number of tokens sent\n    function depositTokens(uint256 amount) external {\n        FactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).allowance(msg.sender, address(this)) >= amount,\n\t\t\t'PointsDeposit: Not allowed to transfer tokens'\n\t\t);\n\t\trequire(\n\t\t\tIERC20(store.currentERC20).transferFrom(msg.sender, address(this), amount),\n\t\t\t'PointsDeposit: Error transferring tokens'\n\t\t);\n\n\t\tstore.totalUserPoints[msg.sender] += amount;\n\t\tstore.currentUserPoints[msg.sender] += amount;\n\n\t\temit ReceivedTokens(\n            msg.sender,\n            store.currentERC20,\n            amount,\n            store.currentUserPoints[msg.sender]\n        );\n\t}\n}"
    },
    "contracts/Factory/facets/QueryingLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\ncontract PointsQuery is AccessControlEnumerable {\n    function getUserPoints(address userAddress) view external returns(uint balance) {\n        balance = FactoryStorage.layout().currentUserPoints[userAddress];\n    }\n\n    function getTotalUserPoints(address userAddress) view external returns(uint balance) {\n        balance = FactoryStorage.layout().totalUserPoints[userAddress];\n    }\n}"
    },
    "contracts/Factory/facets/TokensFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { FactoryStorage } from \"../AppStorage.sol\";\nimport { AccessControlEnumerable } from \"../../common/DiamondStorage/AccessControlEnumerable.sol\";\nimport { FactoryHandlerRoles } from '../AccessControlRoles.sol';\n\n/// @title \tOur Facet creator for tokens\n/// @notice You can use this contract to manage the use of tokens\ncontract TokensFacet is AccessControlEnumerable, FactoryHandlerRoles {\n\t/// @notice Record of a change in accepted tokens\n    /// @param \tcontractAddress contains the address of the tokens contract \n    /// @param \tpriceToDeploy contains the deployment cost for the token\n    /// @param \tresponsible address of the person that implement the new token\n\tevent ChangedToken(address contractAddress, uint priceToDeploy, address responsible);\n\t/// @notice This event stores in the blockchain when the tokens are withdrawed from the contract\n    /// @param \trecipient address who will recieve the tokens\n    /// @param \ttoken contains the address of the tokens contract to withdraw\n\t/// @param \tamount total of tokens to recieve\n\tevent WithdrawTokens(address recipient, address token, uint amount);\n\n\t/// @notice Transfers tokens from the factory to any of the OWNER addresses\n\t/// @dev \tAccessControl makes sure only an OWNER can withdraw\n\t/// @param \tamount\tAmount of tokens to withdraw\n\tfunction withdrawTokens(uint amount) public onlyRole(ADMINISTRATOR) {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tIERC20(store.currentERC20).transfer(msg.sender, amount);\n\t\temit WithdrawTokens(msg.sender, store.currentERC20, amount);\n\t}\n\n\t/// @notice\tAdds an address to the list of allowed minters\n\t/// @param\t_token\tAddress of the new Token\n\t/// @param\t_priceToDeploy\tPrice of deployment for the new Token\n\tfunction changeToken(address _token, uint _priceToDeploy) public onlyRole(ADMINISTRATOR) {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tstore.currentERC20 = _token;\n\t\tstore.deploymentCostForToken[_token] = _priceToDeploy;\n\t\temit ChangedToken(_token, _priceToDeploy, msg.sender);\n\t}\n\n\t/// @notice\tReturns the number of required tokens to deploy a contract\n\t/// @return price \tShows the price of deployment for the token\n\tfunction getDeploymentCost() public view returns (uint price) {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\t\tprice = FactoryStorage.layout().deploymentCostForToken[store.currentERC20];\n\t}\n}"
    },
    "contracts/Factory/facets/WithdrawLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25;\n\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { FactoryHandlerRoles } from '../AccessControlRoles.sol';\nimport { FactoryStorage } from \"../AppStorage.sol\";\n\n/// @title \tWithdraw logic for the points system\ncontract PointsWithdraw is AccessControlEnumerable, FactoryHandlerRoles {\n\n    event WithdrewPoints(address user, address token, uint amount);\n\n    function setWithdrawTimeLimit(uint timeInSeconds) public onlyRole(ADMINISTRATOR) {\n        FactoryStorage.layout().transferTimeLimit = timeInSeconds;\n    }\n\n    function roundedTime() internal view returns (uint time) {\n        // Round out by 2 digits\n        time = ((block.timestamp + FactoryStorage.layout().transferTimeLimit) / 100) * 100;\n    }\n\n    function getWithdrawHash(\n        address receiver,\n        address token,\n        uint amount\n    ) public view returns (bytes32) {\n        FactoryStorage.Layout storage facetData = FactoryStorage.layout();\n        require(\n            facetData.currentUserPoints[receiver] >= amount,\n            \"PointsWithdraw: Invalid withdraw amount\"\n        );\n        return keccak256(\n            abi.encodePacked(\n                receiver,\n                token,\n                amount,\n                facetData.currentUserPoints[receiver],\n                roundedTime()\n            )\n        );\n    }\n\n    function getSignedMessageHash(\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n        );\n    }\n\n    function recoverSigner(\n        bytes32 signedMessageHash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        return ecrecover(signedMessageHash, v, r, s);\n    }\n\n    function splitSignature(\n        bytes memory sig\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n\n    function withdraw(\n        uint amount,\n        bytes memory signature\n    ) public {\n\t\tFactoryStorage.Layout storage store = FactoryStorage.layout();\n\n        bytes32 messageHash = getWithdrawHash(msg.sender, store.currentERC20, amount);\n        bytes32 ethSignedMessageHash = getSignedMessageHash(messageHash);\n        require(\n            hasRole(\n                WITHDRAW_SIGNER,\n                recoverSigner(ethSignedMessageHash, signature)\n            ),\n            \"PointsHandler: Invalid withdraw request\"\n        );\n        require(\n            store.currentUserPoints[msg.sender] >= amount,\n            \"PointsHandler: Insufficient points balance\"\n        );\n        store.currentUserPoints[msg.sender] -= amount;\n        IERC20(store.currentERC20).transfer(msg.sender, amount);\n        emit WithdrewPoints(msg.sender, store.currentERC20, amount);\n    }\n}"
    },
    "contracts/tokens/RAIR Token Facets/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\nimport '../../common/AccessControl.sol';\n\nstruct range {\n\tuint rangeStart;\n\tuint rangeEnd;\n\tuint tokensAllowed;\n\tuint mintableTokens;\n\tuint lockedTokens;\n\tuint rangePrice;\n\tstring rangeName;\n}\n\nstruct product {\n\tuint startingToken;\n\tuint endingToken;\n\tuint mintableTokens;\n\tstring name;\n\tuint[] rangeList;\n}\n\nstruct AppStorage721 {\n\t// ERC721\n\tstring _name;\n\tstring _symbol;\n\tmapping(uint256 => address) _owners;\n\tmapping(address => uint256) _balances;\n\tmapping(uint256 => address) _tokenApprovals;\n\tmapping(address => mapping(address => bool)) _operatorApprovals;\n\t// ERC721 Enumerable\n\tmapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\tmapping(uint256 => uint256) _ownedTokensIndex;\n\tuint256[] _allTokens;\n\tmapping(uint256 => uint256) _allTokensIndex;\n\t// Access Control Enumerable\n\tmapping(bytes32 => RoleData) _roles;\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n\t// App\n\tstring baseURI;\n\taddress factoryAddress;\n\tuint16 royaltyFee;\n\tproduct[] products;\n\trange[] ranges;\n\tmapping(uint => uint) tokenToProduct;\n\tmapping(uint => uint) tokenToRange;\n\tmapping(uint => string) uniqueTokenURI;\n\tmapping(uint => string) productURI;\n\tmapping(uint => bool) appendTokenIndexToProductURI;\n\tbool appendTokenIndexToBaseURI;\n\tmapping(uint => uint[]) tokensByProduct;\n\tstring contractMetadataURI;\n\tmapping(uint => uint) rangeToProduct;\n\tmapping(uint => bool) _minted;\n\t// August 2022 - Metadata File Extension Update\n\tmapping(uint => string) rangeURI;\n\tmapping(uint => bool) appendTokenIndexToRangeURI;\n\tstring _metadataExtension;\n\t// Always add new variables at the end of the struct\n}\n\nlibrary LibAppStorage721 {\n\t/// @notice this funtion set the storage of the diamonds 721 contracts \n\tfunction diamondStorage() internal pure\treturns (AppStorage721 storage ds) {\n\t\tassembly {\n\t\t\tds.slot := 0\n\t\t}\n\t}\n}\n\n/// @title  This is contract to manage the access control of the RAIR token facet\n/// @notice You can use this contract to administrate roles of the app market\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from Context\ncontract AccessControlAppStorageEnumerable721 is Context {\n\tAppStorage721 internal s;\n\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\n\t/// @notice This event stores in the blockchain when we change an admin role\n    /// @param  role Contains the role we want to update\n    /// @param  previousAdminRole contains the previous status of the role\n\t/// @param  newAdminRole contains the new status of the role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when we grant a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to grant the role\n\t/// @param  sender contains the address that is changing the role of the account\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\t/// @notice This event stores in the blockchain when we revoke a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to revoke the role\n\t/// @param  sender contains the address that is changing the role of the account\n\tevent RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n\tmodifier onlyRole(bytes32 role) {\n\t\t_checkRole(role, _msgSender());\n\t\t_;\n\t}\n\n\t/// @notice Allow us to renounce to a role\n\t/// @dev \tCurrently you can only renounce to your own roles\n\t/// @param \trole Contains the role to remove from our account\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction renounceRole(bytes32 role, address account) public {\n\t\trequire(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\t\t_revokeRole(role, account);\n\t}\n\n\t/// @notice Allow us to grant a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to grant\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n\t\t_grantRole(role, account);\n\t}\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n\t\t_revokeRole(role, account);\n\t}\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n\tfunction _checkRole(bytes32 role, address account) internal view {\n\t\tif (!hasRole(role, account)) {\n\t\t\trevert(\n\t\t\t\tstring(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\t\"AccessControl: account \",\n\t\t\t\t\t\tStrings.toHexString(uint160(account), 20),\n\t\t\t\t\t\t\" is missing role \",\n\t\t\t\t\t\tStrings.toHexString(uint256(role), 32)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n\t/// @return bool that indicates if an account has or not a role\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn s._roles[role].members[account];\n\t}\n\n\t/// @notice Allow us to check the admin role that contains a role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return bytes that indicates if an account has or not an admin role\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn s._roles[role].adminRole;\n\t}\n\n\t/// @notice Allow us to check the address of an indexed position for the role list\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \tindex Contains the indexed position to verify inside the role members list\n\t/// @return address that indicates the address indexed in that position\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn s._roleMembers[role].at(index);\n\t}\n\n\t/// @notice Allow us to check total members that has an selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return uint256 that indicates the total accounts with that role\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn s._roleMembers[role].length();\n\t}\n\n\t/// @notice Allow us to modify a rol and set it as an admin role\n\t/// @param \trole Contains the role that we want to modify\n\t/// @param \tadminRole Contains the admin role that we want to set\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\ts._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\ts._roleMembers[role].remove(account);\n\t\t}\n\t}\n\n\t/// @notice Allow us to grant a new role to an account\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe _grantRole function inherited from AccessControlEnumerable\n\t/// @param \trole Contains the facet addresses and function selectors\n    /// @param \taccount Contains the facet addresses and function selectors\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\ts._roleMembers[role].add(account);\n\t\t}\n\t}\n}"
    },
    "contracts/tokens/RAIR-ERC721-Diamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.25; \n\n// Interfaces\n//import \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nimport \"../diamondStandard/interfaces/IDiamondLoupe.sol\";\n\nimport './RAIR Token Facets/AppStorage.sol';\n\n/// @title  RAIR 721 Diamond\n/// @notice Diamond Contract implementing the bare minimum ERC-721 features\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721 & ERC165\ncontract RAIR_ERC721_Diamond is AccessControlAppStorageEnumerable721, ERC165 {\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n\tbytes32 public constant MINTER = keccak256(\"MINTER\");\n\tbytes32 public constant TRADER = keccak256(\"TRADER\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\t\n\t/// @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n\tconstructor(string memory name_, string memory symbol, address creatorAddress_, uint16 creatorRoyalty_) {\n\t\ts._name = name_;\n\t\ts._symbol = symbol;\n\t\t\n\t\ts.factoryAddress = msg.sender;\n\t\ts.royaltyFee = creatorRoyalty_;\n\t\t_setRoleAdmin(MINTER, CREATOR);\n\t\t_setRoleAdmin(TRADER, CREATOR);\n\t\t_grantRole(CREATOR, creatorAddress_);\n\t\t_grantRole(MINTER, creatorAddress_);\n\t\t_grantRole(TRADER, creatorAddress_);\n\t}\n\n\t/// @notice This function allows us to know the factory address \n    /// @return address Contains the address of the factory contract\n\tfunction getFactoryAddress() public view returns (address) {\n\t\treturn s.factoryAddress;\n\t}\n\n\t/// @notice This function allows us to know the URI of the contract \n    /// @return address Contains the string with all the URI, this string is saved in memory \n\tfunction contractURI() public view returns (string memory) {\n\t\treturn s.contractMetadataURI;\n\t}\n\n\t/// @notice This function allows us to know if and interface is suported\n\t/// @param \tinterfaceId Contains the facet addresses and function selectors\n\t/// @return bool contains the value for the interface, it could be true or false\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n        \tinterfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n\tfallback() external {\n\t\taddress facet = IDiamondLoupe(s.factoryAddress).facetAddress(msg.sig);\n\t\tassembly {\n\t\t\t// copy function selector and any arguments\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\t// execute function call using the facet\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\t// get any return value\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\t// return any return value or error back to the caller\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(0, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(0, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}