{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC777/ERC777.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _send(_msgSender(), recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return\n            operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators cannot\n     * call `transferFrom` (unless they have allowance), and accounts with\n     * allowance cannot call `operatorSend` (unless they are operators).\n     *\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(holder, spender, amount);\n        _send(holder, recipient, amount, \"\", \"\", false);\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with the caller address as the `operator` and with\n     * `userData` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal virtual {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: transfer from the zero address\");\n        require(to != address(0), \"ERC777: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal virtual {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal virtual {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC777: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Emitted when `amount` tokens are created by `operator` and assigned to `to`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` destroys `amount` tokens from `account`.\n     *\n     * Note that some additional user `data` and `operatorData` can be logged in the event.\n     */\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    /**\n     * @dev Emitted when `operator` is made operator for `tokenHolder`\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Emitted when `operator` is revoked its operator status for `tokenHolder`\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Sender.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/introspection/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/common/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct RoleData {\n\tmapping(address => bool) members;\n\tbytes32 adminRole;\n}\n \n/// @title  A contract that administrate roles & access\n/// @notice You can use this contract to modify and define the role of an user\nabstract contract AccessControlEnumerable is Context {\t\n    /// @notice This event stores in the blockchain when an admin role changes\n    /// @param  role Contains the admin role that we want to use \n    /// @param  previousAdminRole Contains the previous admin role\n    /// @param  newAdminRole Contains the new admin role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when a role is granted\n    /// @param  role Contains the admin role that we want to use \n    /// @param  account Contains the account we want to add to a new role\n    /// @param  sender Contains the sender of the role petition\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    /// @notice This event stores in the blockchain when a role is revoked\n    /// @param  role Contains the admin role that we want to use \n    /// @param  account Contains the account we want to add to a new role\n    /// @param  sender Contains the sender of the role petition\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /// @notice Allow an user to quit an owned role\n    /// @notice The account that sends the petition needs to be the same that will renounce to a role\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use.    \n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    /// @notice Allow an admin to asign a new role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /// @notice Allow an admin to revoke a role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to verify \n    /// @param  account Contains the account address to check. \n    /// @return role in boolean, if the account has the selected role\n    function hasRole(bytes32 role, address account) public view virtual returns (bool);\n\n\t/// @notice Allow us to verify the branch of roles asociated to an father role\n    /// @param  role Contains the role that we want to verify\n    /// @return bytes32 with the child role\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32);\n\n    /// @notice Check if the account with the index has the desired role\n    /// @param  role Contains the role that we want to use \n    /// @param  index Contains the index asociated to an account\n    /// @return address of the account with the index position in the list of the desired role\n\tfunction getRoleMember(bytes32 role, uint256 index) public view virtual returns (address);\n\n    /// @notice Allow to verify if the account has a role\n    /// @param  role Contains the role that we want to verify\n    /// @return uint256 wuth he total of members with the desired role \n\tfunction getRoleMemberCount(bytes32 role) public view virtual returns (uint256);\n\n    /// @param role Contains the role that we want to use \n    /// @param adminRole Contains the new admin role to use\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual;\n\n    /// @notice Grants a role to an account\n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n\tfunction _grantRole(bytes32 role, address account) internal virtual;\n\n    /// @notice Revokes a role to an account \n    /// @param  role Contains the role that we want to use \n    /// @param  account Contains the account address to use. \n\tfunction _revokeRole(bytes32 role, address account) internal virtual;\n}"
    },
    "contracts/common/DiamondStorage/AccessControlEnumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { Context } from \"@openzeppelin/contracts/utils/Context.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport { AccessControlEnumerableStorage } from \"./AccessControlEnumerableStorage.sol\";\n\nabstract contract AccessControlEnumerable is Context {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    \n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn AccessControlEnumerableStorage.layout()._roles[role].members[account];\n\t}\n\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn AccessControlEnumerableStorage.layout()._roles[role].adminRole;\n\t}\n\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn AccessControlEnumerableStorage.layout()._roleMembers[role].at(index);\n\t}\n\t\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn AccessControlEnumerableStorage.layout()._roleMembers[role].length();\n\t}\n\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\tAccessControlEnumerableStorage.layout()._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\tAccessControlEnumerableStorage.layout()._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\tAccessControlEnumerableStorage.layout()._roleMembers[role].add(account);\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\tAccessControlEnumerableStorage.layout()._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\tAccessControlEnumerableStorage.layout()._roleMembers[role].remove(account);\n\t\t}\n\t}\n}"
    },
    "contracts/common/DiamondStorage/AccessControlEnumerableStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport { EnumerableSet } from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary AccessControlEnumerableStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.AccessControlEnumerable');\n\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    struct Layout {\n        mapping(bytes32 => RoleData) _roles;\n        mapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/Credits/AccessControlRoles.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19; \n\nabstract contract CreditHandlerRoles {\n\tbytes32 public constant ADMINISTRATOR = keccak256(\"rair.creditConsumer.administrator\");\n\tbytes32 public constant ALLOWED_ERC777 = keccak256(\"rair.creditConsumer.allowedTokens\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n}"
    },
    "contracts/Credits/CreditHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\n\nimport { Diamond } from '../diamondStandard/Diamond.sol';\nimport { AccessControlEnumerable } from '../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { CreditHandlerRoles } from './AccessControlRoles.sol';\n\ncontract CreditHandler is Diamond, AccessControlEnumerable, CreditHandlerRoles {\n\tIERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n    \n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\n\t\t_ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\n\t\t_setRoleAdmin(ADMINISTRATOR, ADMINISTRATOR);\n\t\t_setRoleAdmin(ALLOWED_ERC777, ADMINISTRATOR);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\t\t_grantRole(ADMINISTRATOR, msg.sender);\n\t}\n}"
    },
    "contracts/Credits/Facets/DepositLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\n\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { CreditHandlerRoles } from '../AccessControlRoles.sol';\nimport { CreditHandlerStorage } from '../Storage/CreditHandlerStorage.sol';\n\n/// @title \tDeposit logic for the credit system\n/// @notice Uses the ERC777 receiver hook to trigger additional logic\ncontract CreditDeposit is AccessControlEnumerable, CreditHandlerRoles {\n    /// @notice This event stores the user that deposited tokens into the contract\n    /// @param\tuserAddress             Public address of the user depositing\n    /// @param \ttokenAddress            Address of the ERC777 contract used\n    /// @param \tamount                  Amount of tokens transferred to this contract\n\t/// @param \ttotalTokensDeposited    Total amount of tokens deposited by the user\n\tevent ReceivedTokens(address userAddress, address tokenAddress, uint amount, uint totalTokensDeposited);\n\n\t/// @notice Function called by an ERC777 when they send tokens\n\t/// @dev   \tThis is our deposit mechanism\n\t/// @param \toperator The ERC777 operator calling the send() function\n\t/// @param \tfrom The owner of the tokens\n\t/// @param \tto The recipient of the tokens\n\t/// @param \tamount The number of tokens sent\n\t/// @param \tuserData bytes sent from the send call\n\t/// @param \toperatorData bytes sent from the operator\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external onlyRole(ALLOWED_ERC777) {\n        require(to == address(this), \"CreditConsumer: Invalid destination\");\n        CreditHandlerStorage.Layout storage storageData = CreditHandlerStorage.layout();\n\t\tstorageData.userCreditBalance[msg.sender][from] += amount;\n\t\tstorageData.overallUserCreditBalance[from] += amount;\n\t\temit ReceivedTokens(\n            from,\n            msg.sender,\n            amount,\n            storageData.userCreditBalance[msg.sender][from]\n        );\n\t}\n}"
    },
    "contracts/Credits/Facets/QueryingLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { CreditHandlerRoles } from '../AccessControlRoles.sol';\nimport { CreditHandlerStorage } from '../Storage/CreditHandlerStorage.sol';\n\n/// @title \tDeposit logic for the credit system\n/// @notice Uses the ERC777 receiver hook to trigger additional logic\ncontract CreditQuery is AccessControlEnumerable, CreditHandlerRoles {\n    function getUserCredits(address token, address userAddress) view external returns(uint balance) {\n        balance = CreditHandlerStorage.layout().userCreditBalance[token][userAddress];\n    }\n\n    function getTotalUserCredits(address userAddress) view external returns(uint balance) {\n        balance = CreditHandlerStorage.layout().overallUserCreditBalance[userAddress];\n    }\n}"
    },
    "contracts/Credits/Facets/WithdrawLogic.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\n\nimport { AccessControlEnumerable } from '../../common/DiamondStorage/AccessControlEnumerable.sol';\nimport { CreditHandlerRoles } from '../AccessControlRoles.sol';\nimport { CreditHandlerStorage } from '../Storage/CreditHandlerStorage.sol';\n\n/// @title \tWithdraw logic for the credit system\n/// @notice Uses the ERC777 interface to transfer tokens back to the users\ncontract CreditWithdraw is AccessControlEnumerable, CreditHandlerRoles {\n    function getWithdrawHash(\n        address receiver,\n        address erc777Address,\n        uint amount,\n        uint nonce\n    ) public pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(receiver, erc777Address, amount, nonce)\n        );\n    }\n\n    function getSignedMessageHash(\n        bytes32 messageHash\n    ) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n        );\n    }\n\n    function recoverSigner(\n        bytes32 signedMessageHash,\n        bytes memory signature\n    ) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\n        return ecrecover(signedMessageHash, v, r, s);\n    }\n\n    function splitSignature(\n        bytes memory sig\n    ) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"invalid signature length\");\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n\n    function withdraw(\n        address erc777Address,\n        uint amount,\n        uint nonce,\n        bytes memory signature\n    ) public {\n        require(\n            hasRole(ALLOWED_ERC777, erc777Address),\n            \"CreditHandler: Invalid token address\"\n        );\n        bytes32 messageHash = getWithdrawHash(msg.sender, erc777Address, amount, nonce);\n        bytes32 ethSignedMessageHash = getSignedMessageHash(messageHash);\n        require(\n            hasRole(\n                ADMINISTRATOR,\n                recoverSigner(ethSignedMessageHash, signature)\n            ),\n            \"CreditHandler: Invalid withdraw request\"\n        );\n        CreditHandlerStorage.Layout storage userData = CreditHandlerStorage.layout();\n        require(\n            userData.overallUserCreditBalance[msg.sender] > amount,\n            \"CreditHandler: Insufficient user balance\"\n        );\n        require(\n            userData.userCreditBalance[erc777Address][msg.sender] > amount,\n            \"CreditHandler: Insufficient user balance\"\n        );\n        userData.overallUserCreditBalance[msg.sender] -= amount;\n        userData.userCreditBalance[erc777Address][msg.sender] -= amount;\n        IERC777(erc777Address).send(msg.sender, amount, \"RAIR Credit Withdraw\");\n    }\n}"
    },
    "contracts/Credits/Storage/CreditHandlerStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nlibrary CreditHandlerStorage {\n    bytes32 internal constant STORAGE_SLOT =\n        keccak256('rair.contracts.storage.CreditConsumer');\n\n    struct Layout {\n        mapping(address => mapping(address => uint)) userCreditBalance;\n        mapping(address => uint) overallUserCreditBalance;\n    }\n\n    function layout() internal pure returns (Layout storage l) {\n        bytes32 slot = STORAGE_SLOT;\n        assembly {\n            l.slot := slot\n        }\n    }\n}"
    },
    "contracts/diamondStandard/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\n\ncontract Diamond {    \n\n    constructor(address _contractOwner, address _diamondCutFacet) payable {        \n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet, \n            action: IDiamondCut.FacetCutAction.Add, \n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");        \n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = address(bytes20(ds.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n                case 0 {\n                    revert(0, returndatasize())\n                }\n                default {\n                    return(0, returndatasize())\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/diamondStandard/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts/diamondStandard/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {                    \n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/diamondStandard/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\n\ncontract OwnershipFacet is IERC173 {\n    function transferOwnership(address _newOwner) external override {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    function owner() external override view returns (address owner_) {\n        owner_ = LibDiamond.contractOwner();\n    }\n}\n"
    },
    "contracts/diamondStandard/facets/Test1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Test1Facet {\n    event TestEvent(address something);\n\n    function test1Func1() external {}\n\n    function test1Func2() external {}\n\n    function test1Func3() external {}\n\n    function test1Func4() external {}\n\n    function test1Func5() external {}\n\n    function test1Func6() external {}\n\n    function test1Func7() external {}\n\n    function test1Func8() external {}\n\n    function test1Func9() external {}\n\n    function test1Func10() external {}\n\n    function test1Func11() external {}\n\n    function test1Func12() external {}\n\n    function test1Func13() external {}\n\n    function test1Func14() external {}\n\n    function test1Func15() external {}\n\n    function test1Func16() external {}\n\n    function test1Func17() external {}\n\n    function test1Func18() external {}\n\n    function test1Func19() external {}\n\n    function test1Func20() external {}\n\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {}\n}\n"
    },
    "contracts/diamondStandard/facets/Test2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract Test2Facet {\n    function test2Func1() external {}\n\n    function test2Func2() external {}\n\n    function test2Func3() external {}\n\n    function test2Func4() external {}\n\n    function test2Func5() external {}\n\n    function test2Func6() external {}\n\n    function test2Func7() external {}\n\n    function test2Func8() external {}\n\n    function test2Func9() external {}\n\n    function test2Func10() external {}\n\n    function test2Func11() external {}\n\n    function test2Func12() external {}\n\n    function test2Func13() external {}\n\n    function test2Func14() external {}\n\n    function test2Func15() external {}\n\n    function test2Func16() external {}\n\n    function test2Func17() external {}\n\n    function test2Func18() external {}\n\n    function test2Func19() external {}\n\n    function test2Func20() external {}\n}\n"
    },
    "contracts/diamondStandard/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/diamondStandard/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/diamondStandard/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/diamondStandard/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/diamondStandard/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\n                // add facet for selector\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n                    // only useful if immutable functions exist\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/diamondStandard/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\n\n// It is expected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {    \n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n\n\n}\n"
    },
    "contracts/Factory/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"../common/AccessControl.sol\";\n\nstruct AppStorage {\n\t// Access Control Enumerable\n\tmapping(bytes32 => RoleData) _roles;\n\tstring failsafe;\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n\t// App\n\taddress[] creators;\n\tmapping(address => address[]) creatorToContracts;\n\tmapping(address => address) contractToCreator;\n\tmapping(address => uint) deploymentCostForToken;\n\t// Always add new variables at the end of the struct!\n}\n\nlibrary LibAppStorage {\n\tfunction diamondStorage() internal pure\treturns (AppStorage storage ds) {\n\t\tassembly {\n\t\t\tds.slot := 0\n\t\t}\n\t}\n}\n\n/// @title \tAn Access Control contract\n/// @notice You can use this contract to modify and define the role of an user\ncontract AccessControlAppStorageEnumerable is Context, AccessControlEnumerable {\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\t\n\tAppStorage internal s;\n\n\t/// @notice This function allow us to know if an user has or not an specific role\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe hasrole function inherited from AccessControlEnumerable\n\t/// @param \trole Contains the role we want to verify\n    /// @param \taccount Contains the address to match with the verification \n\t/// @return bool Answer if the account has the input role or not\n\tfunction hasRole(bytes32 role, address account) public view override returns (bool) {\n\t\treturn s._roles[role].members[account];\n\t}\n\n\t/// @notice Allows us to see what role is available to modify with the selected role\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe getRoleAdmin function inherited from AccessControlEnumerable\n\t/// @param \trole Contains the role that we want to check\n\t/// @return bytes32 the rol that in available to change\n\tfunction getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n\t\treturn s._roles[role].adminRole;\n\t}\n\n\t/// @notice Allow us to use an index position to verify the account that has a role\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe getRoleMember function inherited from AccessControlEnumerable\n\t/// @param \trole Contains an specific role to check\n    /// @param \tindex Contains the position of the array that we want to verify\n\t/// @return address of the account with that position of the list of the selected role\n\tfunction getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\n\t\treturn s._roleMembers[role].at(index);\n\t}\n\n\t/// @notice Allow us to know the total of members that has a role\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe getRoleMemberCount function inherited from AccessControlEnumerable\n\t/// @param \trole Contains an specific role to check\n\t/// @return uint256 answer the cuantity of accounts with that role\n\tfunction getRoleMemberCount(bytes32 role) public view override returns (uint256) {\n\t\treturn s._roleMembers[role].length();\n\t}\n\n\t/// @notice Allow us to use to set a new admin role\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe _setRoleAdmin function inherited from AccessControlEnumerable\n\t/// @param \trole Contains an specific role to check\n    /// @param \tadminRole Contains the new admin role we want to provide\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\ts._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\t/// @notice Allow us to grant a new role to an account\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe _grantRole function inherited from AccessControlEnumerable\n\t/// @param \trole Contains the facet addresses and function selectors\n    /// @param \taccount Contains the facet addresses and function selectors\n\tfunction _grantRole(bytes32 role, address account) internal override {\n\t\tif (!hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\ts._roleMembers[role].add(account);\n\t\t}\n\t}\n\n\t/// @notice Allow us to revoke a role of an account\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe _revokeRole function inherited from AccessControlEnumerable\n\t/// @param \trole Contains the facet addresses and function selectors\n    /// @param \taccount Contains the facet addresses and function selectors\n\tfunction _revokeRole(bytes32 role, address account) internal override {\n\t\tif (hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\ts._roleMembers[role].remove(account);\n\t\t}\n\t}\n}"
    },
    "contracts/Factory/facets/creatorsFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport '../AppStorage.sol';\n\n/// @title \tOur Facet creators contract\n/// @notice You can use this contract to view the creator of contracts and the list of contractsdeployed\ncontract creatorFacet is AccessControlAppStorageEnumerable {\n\t/// @notice Returns the number of addresses that have deployed a contract\n\t/// @return count with the total of creators of this contract\n\tfunction getCreatorsCount() public view returns(uint count) {\n\t\treturn s.creators.length;\n\t}\n\n\t/// @notice Returns a single address inside the creators array\n\t/// @param \tindex number of the index for look inside our array\n\t/// @return creator \tAddress of the selected index\n\tfunction getCreatorAtIndex(uint index) public view returns (address creator) {\n\t\tcreator = s.creators[index];\n\t}\n\n\t/// @notice Returns the number of contracts deployed by an address\n\t/// @dev\tUse alongside creatorToContracts for the full list of tokens \n\t/// @param\tdeployer\tWallet address to query\n\t/// @return count \tNumber of contracts deployed by the deployer\n\tfunction getContractCountOf(address deployer) public view returns(uint count) {\n\t\treturn s.creatorToContracts[deployer].length;\n\t}\n\n\t/// @notice Necessary view function now that public mappings are not possible\n\t/// @param \tdeployer Contains the facet addresses and function selectors\n\t/// @param \tindex Contains the facet addresses and function selectors\n\t/// @return deployedContract \tAddress of the deployed ERC721\n\tfunction creatorToContractIndex(address deployer, uint index) public view returns(address deployedContract) {\n\t\treturn s.creatorToContracts[deployer][index];\n\t}\n\n\t/// @notice Returns the whole array of deployed addresses of a creator\n\t/// @param \tdeployer Contains the facet addresses and function selectors\n\t/// @return deployedContracts \tAddresses of the deployed contracts  \n\tfunction creatorToContractList(address deployer) public view returns(address[] memory deployedContracts) {\n\t\treturn s.creatorToContracts[deployer];\n\t}\n\n\t/// @notice Returns the address of the creator given a deployed contract's address\n\t/// @param \tdeployedContract Contains the facet addresses and function selectors\n\t/// @return creator \tAddress of the contracts creator\n\tfunction contractToCreator(address deployedContract) public view returns (address creator) {\n\t\tcreator = s.contractToCreator[deployedContract];\n\t}\n}"
    },
    "contracts/Factory/facets/ERC777ReceiverFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport '../AppStorage.sol';\nimport '../../tokens/RAIR-ERC721-Diamond.sol';\n\n/// @title \tOur Facet creator for ERC777 contracts\n/// @notice You can use this contract to deploy new ERC777 contracts\ncontract ERC777ReceiverFacet is IERC777Recipient, AccessControlAppStorageEnumerable {\n\tbytes32 constant ERC777 = keccak256(\"ERC777\");\n\tbytes32 constant OWNER = keccak256(\"OWNER\");\n\t\n\t/// @notice This event stores in the blockchain when a new contract is deployed\n    /// @param\tdeployerAddress Contains the address of the deployer of the contract \n    /// @param \tdeploymentIndex Contains the corresponding ID for the deployment\n    /// @param \tdeploymentAddress Contains the address where the contract was deployed\n\t/// @param \tdeploymentName Contains the name of the deployed contract\n\tevent DeployedContract(address deployerAddress, uint deploymentIndex, address deploymentAddress, string deploymentName);\n\t\n\t/// @notice Function called by an ERC777 when they send tokens\n\t/// @dev   \tThis is our deployment mechanism for ERC721 contracts!\n\t/// @param \toperator The ERC777 operator calling the send() function\n\t/// @param \tfrom The owner of the tokens\n\t/// @param \tto The recipient of the tokens\n\t/// @param \tamount The number of tokens sent\n\t/// @param \tuserData bytes sent from the send call\n\t/// @param \toperatorData bytes sent from the operator\n\tfunction tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external onlyRole(ERC777) override {\n\t\tAppStorage storage s = LibAppStorage.diamondStorage();\n\t\trequire(amount >= s.deploymentCostForToken[msg.sender], 'RAIR Factory: not enough RAIR tokens to deploy a contract');\n\n\t\tif (amount - (s.deploymentCostForToken[msg.sender]) > 0) {\n\t\t\tIERC777(msg.sender).send(from, amount - (s.deploymentCostForToken[msg.sender]), bytes(\"RAIR\"));\n\t\t}\n\t\taddress[] storage deploymentsFromOwner = s.creatorToContracts[from];\n\t\t\n\t\tif (deploymentsFromOwner.length == 0) {\n\t\t\ts.creators.push(from);\n\t\t}\n\n\t\tRAIR_ERC721_Diamond newToken = new RAIR_ERC721_Diamond(string(userData), from, 30000);\n\t\tdeploymentsFromOwner.push(address(newToken));\n\t\ts.contractToCreator[address(newToken)] = from;\n\t\temit DeployedContract(from, deploymentsFromOwner.length - 1, address(newToken), string(userData));\n\t}\n}"
    },
    "contracts/Factory/facets/TokensFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport '../AppStorage.sol';\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\n\n/// @title \tOur Facet creator for tokens\n/// @notice You can use this contract to manage the use of tokens\ncontract TokensFacet is AccessControlAppStorageEnumerable {\n\tbytes32 constant OWNER = keccak256(\"OWNER\");\n\tbytes32 constant ERC777 = keccak256(\"ERC777\");\n\t\n\t/// @notice This event stores in the blockchain when a new token is indexed as accepted \n    /// @param \tcontractAddress contains the address of the tokens contract \n    /// @param \tpriceToDeploy contains the deployment cost for the token\n    /// @param \tresponsible address of the person that implement the new token\n\tevent AcceptedToken(address contractAddress, uint priceToDeploy, address responsible);\n\t/// @notice This event stores in the blockchain when a token is revoked\n    /// @param \terc777 contains the address of the tokens contract to remove\n    /// @param \tresponsible address of the person that revokes the token\n\tevent RemovedToken(address erc777, address responsible);\n\t/// @notice This event stores in the blockchain when the tokens are withdrawed from the contract\n    /// @param \trecipient address who will recieve the tokens\n    /// @param \terc777 contains the address of the tokens contract to withdraw\n\t/// @param \tamount total of tokens to recieve\n\tevent WithdrawTokens(address recipient, address erc777, uint amount);\n\n\t/// @notice Transfers tokens from the factory to any of the OWNER addresses\n\t/// @dev \tIf the contract has less than the amount, the ERC777 contract will revert\n\t/// @dev \tAccessControl makes sure only an OWNER can withdraw\n\t/// @param \terc777\tAddress of the ERC777 contract\n\t/// @param \tamount\tAmount of tokens to withdraw\n\tfunction withdrawTokens(address erc777, uint amount) public onlyRole(OWNER) {\n\t\trequire(hasRole(ERC777, erc777), \"RAIR Factory: Specified contract isn't an approved erc777 contract\");\n\t\tIERC777(erc777).send(msg.sender, amount, bytes(\"Factory Withdraw\"));\n\t\temit WithdrawTokens(msg.sender, erc777, amount);\n\t}\n\n\t/// @notice\tAdds an address to the list of allowed minters\n\t/// @param\t_erc777Address\tAddress of the new Token\n\t/// @param\t_priceToDeploy\tPrice of deployment for the new Token\n\tfunction acceptNewToken(address _erc777Address, uint _priceToDeploy) public onlyRole(OWNER) {\n\t\tgrantRole(ERC777, _erc777Address);\n\t\ts.deploymentCostForToken[_erc777Address] = _priceToDeploy;\n\t\temit AcceptedToken(_erc777Address, _priceToDeploy, msg.sender);\n\t}\n\n\t/// @notice\tRemoves an address from the list of allowed minters\n\t/// @param\t_erc777Address\tAddress of the Token\n\tfunction removeToken(address _erc777Address) public onlyRole(OWNER) {\n\t\trevokeRole(ERC777, _erc777Address);\n\t\ts.deploymentCostForToken[_erc777Address] = 0;\n\t\temit RemovedToken(_erc777Address, msg.sender);\n\t}\n\n\t/// @notice\tReturns the number of required tokens, given an erc777 address\n\t/// @param \terc777 \tContains the facet addresses and function selectors\n\t/// @return price \tShows the price of deployment for the token\n\tfunction getDeploymentCost(address erc777) public view returns (uint price) {\n\t\tprice = s.deploymentCostForToken[erc777];\n\t}\n}"
    },
    "contracts/Factory/FactoryDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\n// Interfaces\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\n\n// Parent classes\n\nimport './AppStorage.sol';\nimport '../diamondStandard/Diamond.sol';\n\n/// @title  RAIR ERC721 Factory\n/// @notice Handles the deployment of ERC721 RAIR Tokens\n/// @author Juan M. Sanchez M.\n/// @dev \tUses AccessControl for the reception of ERC777 tokens!\n/// @dev\tThis contract inherit from Diamon and AccessControlAppStorageEnumerable\ncontract FactoryDiamond is Diamond, AccessControlAppStorageEnumerable {\n\tIERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\t\n\tbytes32 public constant OWNER = keccak256(\"OWNER\");\n\tbytes32 public constant ERC777 = keccak256(\"ERC777\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\n\t\t_ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\n\t\ts.failsafe = 'This is a test!';\n\t\t_setRoleAdmin(OWNER, OWNER);\n\t\t_setRoleAdmin(ERC777, OWNER);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\t\t_grantRole(OWNER, msg.sender);\n\t}\n}"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title IERC165 interface \n/// @notice You can use this contract verify if an interface is supported\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param  interfaceId The interface identifier, as specified in ERC-165\n    /// @dev    Interface identification is specified in ERC-165. This function\n    ///         uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///         `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "contracts/maliciousContracts/receiveEthAttacker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\n/// @title  This is a token protection contract\n/// @notice The function of this contract prevent another contract to recieve the tokens\n/// @dev    This contract will prevent another contract to sustract any token by causing a revert\n/// @dev    The revert will occur if a contract, and not an user, try to buy any token\ncontract ReceiveEthAttacker {\n    constructor() {\n\n    }\n\n    /// @notice Unexpected reverts would stop any token purchase, from the minter or the resale marketplace\n    receive() external payable {\n        require(false, \"Unexpected Revert Attack!\");\n    }\n}"
    },
    "contracts/Marketplace/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct feeSplits {\n\taddress recipient;\n\tuint percentage;\n}\n\nstruct mintingOffer {\n\taddress erc721Address;\n\taddress nodeAddress;\n\tuint rangeIndex;\n\tfeeSplits[] fees;\n\tbool visible;\n}\n\nstruct RoleData {\n\tmapping(address => bool) members;\n\tbytes32 adminRole;\n}\n\nstruct AppStorage {\n\t// Access Control Enumerable\n\tmapping(bytes32 => RoleData) _roles;\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n\t// App\n\tuint16 decimals;\n\tuint decimalPow;\n\tuint nodeFee;\n\tuint treasuryFee;\n\taddress treasuryAddress;\n\tmintingOffer[] mintingOffers;\n\tmapping(address => mapping(uint => uint)) addressToRangeOffer;\n\tmapping(address => uint[]) addressToOffers;\n\t// Always add new fields at the end of the struct, that way the structure can be upgraded\n}\n\nlibrary LibAppStorage {\n\tfunction diamondStorage() internal pure\treturns (AppStorage storage ds) {\n\t\tassembly {\n\t\t\tds.slot := 0\n\t\t}\n\t}\n}\n\n/// @title \tThis is contract to manage the access control of the app market\n/// @notice You can use this contract to administrate roles of the app market\n/// @dev \tNotice that this contract is inheriting from Context\ncontract AccessControlAppStorageEnumerableMarket is Context {\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\t\n\tAppStorage internal s;\n\n\t/// @notice This event stores in the blockchain when we change an admin role\n    /// @param  role Contains the role we want to update\n    /// @param  previousAdminRole contains the previous status of the role\n\t/// @param  newAdminRole contains the new status of the role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when we grant a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to grant the role\n\t/// @param  sender contains the address that is changing the role of the account\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\t/// @notice This event stores in the blockchain when we revoke a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to revoke the role\n\t/// @param  sender contains the address that is changing the role of the account\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n\t/// @notice Allow us to renounce to a role\n\t/// @dev \tCurrently you can only renounce to your own roles\n\t/// @param \trole Contains the role to remove from our account\n\t/// @param \taccount Contains the account that has the role we want to update\n    function renounceRole(bytes32 role, address account) public {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n        _revokeRole(role, account);\n    }\n\n\t/// @notice Allow us to grant a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to grant\n\t/// @param \taccount Contains the account that has the role we want to update\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n    function _checkRole(bytes32 role, address account) internal view {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n\t/// @return bool that indicates if an account has or not a role\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn s._roles[role].members[account];\n\t}\n\n\t/// @notice Allow us to check the admin role that contains a role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return bytes that indicates if an account has or not an admin role\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn s._roles[role].adminRole;\n\t}\n\n\t/// @notice Allow us to check the address of an indexed position for the role list\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \tindex Contains the indexed position to verify inside the role members list\n\t/// @return address that indicates the address indexed in that position\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn s._roleMembers[role].at(index);\n\t}\n\t\n\t/// @notice Allow us to check total members that has an selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return uint256 that indicates the total accounts with that role\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn s._roleMembers[role].length();\n\t}\n\n\t/// @notice Allow us to modify a rol and set it as an admin role\n\t/// @param \trole Contains the role that we want to modify\n\t/// @param \tadminRole Contains the admin role that we want to set\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\ts._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\t/// @notice Allow us to grant a role to an account\n\t/// @param \trole Contains the role that we want to grant\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\ts._roleMembers[role].add(account);\n\t\t}\n\t}\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\ts._roleMembers[role].remove(account);\n\t\t}\n\t}\n}"
    },
    "contracts/Marketplace/Facets/FeesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\nimport '../AppStorage.sol';\n\n/// @title This is contract to manage the facet fees\n/// @notice You can use this contract to update the facet and treasury\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerableMarket\ncontract FeesFacet is AccessControlAppStorageEnumerableMarket {\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\n\t\n\t/// @notice This event stores in the blockchain when we update the decimals of a fee\n    /// @param  decimals Contains the decimals established for the fee\n    /// @param  precalculatedMultiplier Contains the value of the multiplayer for the fee\n\tevent UpdatedDecimals(uint decimals, uint precalculatedMultiplier);\n\t/// @notice This event stores in the blockchain when we update the node fee\n    /// @param  decimals Contains the decimals established for the fee\n    /// @param  newPercentage Contains the value of the percentage to calculate the fee\n\tevent UpdatedNodeFee(uint decimals, uint newPercentage);\n\t/// @notice This event stores in the blockchain when we update the fee of our treasury\n    /// @param  decimals Contains the decimals established for the fee\n    /// @param  newPercentage Contains the value of the percentage to calculate the treasury fee\n\tevent UpdatedTreasuryFee(uint decimals, uint newPercentage);\n\t/// @notice This event stores in the blockchain when we update the decimals of a fee\n    /// @param  newAddress Contains the new address that we set ad treasury\n\tevent UpdatedTreasuryAddress(address newAddress);\n\n\t/// @notice Check the current decimals of the fee\n    /// @return uint16 with the current decimals \n\tfunction getDecimals() public view returns (uint16) {\n\t\treturn s.decimals;\n\t}\n\n\t/// @notice Allow us to update the decimals that we use\n\t///\t@dev\tOnly a MAINTAINER of the contract is allowed to make this change\n\t/// @param \tnewDecimals_ Contains the value of the new decimals that we want to implement\n\tfunction updateDecimals(uint16 newDecimals_) public onlyRole(MAINTAINER) {\n\t\ts.decimals = newDecimals_;\n\t\ts.decimalPow = 10**newDecimals_;\n\t\temit UpdatedDecimals(s.decimals, s.decimalPow);\n\t}\n\n\t/// @notice Allow us to check the value of the fee for the current node\n\t/// @return decimals \tNumber of decimal spaces in the resulting node fee\n\t/// @return nodeFee \tPercentage of any minting offer that belongs to the node address\n\tfunction getNodeFee() public view returns (uint16 decimals, uint nodeFee) {\n\t\treturn (s.decimals, s.nodeFee);\n\t}\n\n\t/// @notice Allow us to update the current fee of the node\n\t///\t@dev\tOnly a MAINTAINER of the contract is allowed to make this change\n\t/// @param \tnewFee_ establish the new value that we want to set as fee\n\tfunction updateNodeFee(uint newFee_) public onlyRole(MAINTAINER) {\n\t\trequire(newFee_ <= 100 * s.decimalPow, \"Marketplace: Invalid Fee!\");\n\t\ts.nodeFee = newFee_;\n\t\temit UpdatedNodeFee(s.decimals, newFee_);\n\t}\n\n\t/// @notice Allow us to check the current Treasury fee\n\t/// @return decimals containt the current decimals that use the fee\n\t/// @return treasuryFee constain the current fee of the treasury\n\tfunction getTreasuryFee() public view returns (uint16 decimals, uint treasuryFee) {\n\t\treturn (s.decimals, s.treasuryFee);\n\t}\n\n\t/// @notice Allow us to modify the current treasury fee\n\t///\t@dev\tOnly a MAINTAINER he new fee that we want to implement for the treasury\n\t/// @param \tnewFee_ establish the new value that we want to set as treasury fee\n\tfunction updateTreasuryFee(uint newFee_) public onlyRole(MAINTAINER) {\n\t\trequire(newFee_ <= 100 * s.decimalPow, \"Marketplace: Invalid Fee!\");\n\t\ts.treasuryFee = newFee_;\n\t\temit UpdatedTreasuryFee(s.decimals, newFee_);\n\t}\n\n\t/// @notice Allow us to check the current Treasury fee\n\t/// @return address which contains the treasury contract address\n\tfunction getTreasuryAddress() public view returns (address) {\n\t\treturn s.treasuryAddress;\n\t}\n\n\t/// @notice Allow us to modify the address that we use as treasury\n\t///\t@dev\tOnly a MAINTAINER he new fee that we want to implement for the treasury\n\t/// @param \tnewAddress_ contains the new address that we want to establish as treasury\n\tfunction updateTreasuryAddress(address newAddress_) public onlyRole(MAINTAINER) {\n\t\ts.treasuryAddress = newAddress_;\n\t\temit UpdatedTreasuryAddress(newAddress_);\n\t}\n}"
    },
    "contracts/Marketplace/Facets/MintingOffersFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\nimport '../AppStorage.sol';\n\ninterface IRAIR721 {\n\tstruct range {\n\t\tuint rangeStart;\n\t\tuint rangeEnd;\n\t\tuint tokensAllowed;\n\t\tuint mintableTokens;\n\t\tuint lockedTokens;\n\t\tuint rangePrice;\n\t\tstring rangeName;\n\t}\n\n\t/// @notice This function returns the information of the selected range\n\t/// @param rangeId \t\t  Contains the specific range that we want to check\n\t/// @return data\t\t  Contains the data inside the range\n\t/// @return productIndex  Contains the index of the products for the range\n\tfunction rangeInfo(uint rangeId) external view returns(range memory data, uint productIndex);\n\t/// @notice This function allow us to mint token from a specific range \n\t/// @param to Contains the address that will mint the token\n    /// @param rangeId Contains the range identification where we want to mint\n\t/// @param indexInRange Contains the index inside the range that we want to use for minting \n\tfunction mintFromRange(address to, uint rangeId, uint indexInRange) external;\n}\n\n\n/// @title  RAIR Diamond - Minting offers facet\n/// @notice Facet in charge of the minting offers in the RAIR Marketplace\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerableMarket\ncontract MintingOffersFacet is AccessControlAppStorageEnumerableMarket {\n\n\t/// @notice This event stores in the blockchain when a Minting Offer is Added\n    /// @param  erc721Address Contains the address of the erc721\n    /// @param  rangeIndex contains the id of the minted token\n\t/// @param  rangeName contains the name of the range where the token is\n\t/// @param  price Contains the price of the offer fot the token\n    /// @param  feeSplitsLength contains the previous status of the offer\n    /// @param  feeSplitsLength Contains the visibility of the offer\n\t/// @param  offerIndex contains the new status of the offer\n\tevent AddedMintingOffer(address erc721Address, uint rangeIndex, string rangeName, uint price, uint feeSplitsLength, bool visible, uint offerIndex);\n\tevent UpdatedMintingOffer(address erc721Address, uint rangeIndex, uint feeSplitsLength, bool visible, uint offerIndex);\n\t\n\tevent MintedToken(address erc721Address, uint rangeIndex, uint tokenIndex, address buyer);\n\n\tmodifier checkMinterRole(address erc721Address) {\n\t\trequire(hasMinterRole(erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\n\t\t_;\n\t}\n\n\tmodifier mintingOfferExists(uint offerIndex_) {\n\t\trequire(s.mintingOffers.length > offerIndex_, \"Minting Marketplace: Minting Offer doesn't exist\");\n\t\t_;\n\t}\n\n\tmodifier offerDoesntExist(address erc721Address, uint rangeIndex) {\n\t\trequire(s.addressToRangeOffer[erc721Address][rangeIndex] == 0, \"Minter Marketplace: Range already has an offer\");\n\t\tif (s.addressToRangeOffer[erc721Address][rangeIndex] == 0 && s.mintingOffers.length > 0) {\n\t\t\trequire(s.mintingOffers[0].erc721Address != erc721Address ||\n\t\t\t\t\t\ts.mintingOffers[0].rangeIndex != rangeIndex,\n\t\t\t\t\t\t\t\"Minter Marketplace: Range already has an offer\");\n\t\t}\n\t\t_;\n\t}\n\n\tfunction _checkCreatorRole(address erc721Address) internal view returns (bool) {\n\t\trequire(\n\t\t\tIAccessControl(erc721Address).hasRole(bytes32(0x00), address(msg.sender)) ||\n\t\t\tIAccessControl(erc721Address).hasRole(bytes32(keccak256(\"CREATOR\")), address(msg.sender)),\n\t\t\t\"Minter Marketplace: Sender isn't the creator of the contract!\");\n\t\treturn true;\n\t}\n\n\t/// @notice Utility function to verify that the recipient of a custom splits ISN'T a contract\n\t/// @dev \tThis isn't a foolproof function, a contract running code in it's constructor has a code size of 0\n\t/// @param \taddr \tAddress to verify\n\t/// @return bool that indicates if the address is a contract or not\n\tfunction isContract(address addr) internal view returns (bool) {\n\t\tuint size;\n\t\tassembly { size := extcodesize(addr) }\n\t\treturn size > 0;\n\t}\n\n\t/// @notice Utility function to verify if the Marketplace has a MINTER role\n\t/// @param  erc721Address \tAddress of the ERC721 token with AccessControl\n\t/// @return bool that indicates if the marketplace has a `MINTER` role or not\n\tfunction hasMinterRole(address erc721Address) internal view returns (bool) {\n\t\treturn IAccessControl(erc721Address).hasRole(bytes32(keccak256(\"MINTER\")), address(this));\n\t}\n\n\t/// @notice Returns the number of offers for a specific ERC721 address\n\t/// @param  erc721Address \tAddress of the ERC721 token\n\t/// @return uint with the total of offers\n\tfunction getOffersCountForAddress(address erc721Address) public view returns (uint) {\n\t\treturn s.addressToOffers[erc721Address].length;\n\t}\n\n\t/// @notice Returns the number of all the minting offers \n\t/// @return uint with the total of offers\n\tfunction getTotalOfferCount() public view returns (uint) {\n\t\treturn s.mintingOffers.length;\n\t}\n\n\t/// @notice This functions show us the information of an offer asociated to a marketplace\n\t/// @param erc721Address Contains the facet addresses and function selectors\n    /// @param rangeIndex Contains the facet addresses and function selectors\n\t/// @return offerIndex Show us the indexed position of the offer\n\t/// @return mintOffer Show us the information about the minting offer \n\t/// @return rangeData Show us the data about the selected range\n\t/// @return productIndex Show us the indexed position for the product inside the range\n\tfunction getOfferInfoForAddress(address erc721Address, uint rangeIndex) public view returns (uint offerIndex, mintingOffer memory mintOffer, IRAIR721.range memory rangeData, uint productIndex) {\n\t\tmintingOffer memory selectedOffer = s.mintingOffers[s.addressToOffers[erc721Address][rangeIndex]];\n\t\t(rangeData, productIndex) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tofferIndex = s.addressToOffers[erc721Address][rangeIndex];\n\t\tmintOffer = selectedOffer;\n\t}\n\n\t/// @notice This function show us the information of an selected minting offer\n\t/// @param \t\tofferIndex Contains the facet addresses and function selectors\n\t/// @return \tmintOffer Show us the information about the minting offer \n\t/// @return \trangeData Show us the data about the selected range\n\t/// @return \tproductIndex Show us the indexed position for the product inside the range\n\tfunction getOfferInfo(uint offerIndex) public view returns (mintingOffer memory mintOffer, IRAIR721.range memory rangeData, uint productIndex) {\n\t\tmintingOffer memory selectedOffer = s.mintingOffers[offerIndex];\n\t\tmintOffer = selectedOffer;\n\t\t(rangeData, productIndex) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t}\n\n\t/// @notice This function allow us to add a new minting offer\n\t/// @param erc721Address_ Contains the address of the minter marketplace contract\n\t/// @param rangeIndex_ Contains the index location of the range where the offer will be placed\n\t/// @param splits Contains the shares and address to pay when the offer is succesfull \n\t/// @param visible_ Contains a boolean to set if the offer is public or not \n\t/// @param nodeAddress_ Contains address of the node where the offer was placed\n\tfunction addMintingOffer(\n\t\taddress erc721Address_,\n\t\tuint rangeIndex_,\n\t\tfeeSplits[] calldata splits,\n\t\tbool visible_,\n\t\taddress nodeAddress_\n\t) external {\n\t\t_addMintingOffer(erc721Address_, rangeIndex_, splits, visible_, nodeAddress_);\n\t}\n\n\t/// @notice This function allow us to create a group of minting offers in a single call\n\t/// @param erc721Address_ Contains the address of the minter marketplace contract\n\t/// @param rangeIndexes Contains the collection of ranges where the offer will be placed\n\t/// @param splits Contains the shares and address to pay when the offer is succesfull \n\t/// @param visibility Contains a collection of booleans that set the offer as public or not \n\t/// @param nodeAddress_ Contains address of the node where the offer was placed\n\tfunction addMintingOfferBatch(\n\t\taddress erc721Address_,\n\t\tuint[] calldata rangeIndexes,\n\t\tfeeSplits[][] calldata splits,\n\t\tbool[] calldata visibility,\n\t\taddress nodeAddress_\n\t) external {\n\t\trequire(rangeIndexes.length > 0, \"Minter Marketplace: No offers sent!\");\n\t\trequire(rangeIndexes.length == visibility.length && splits.length == visibility.length, \"Minter Marketplace: Arrays should have the same length\");\n\t\tfor (uint i = 0; i < rangeIndexes.length; i++) {\n\t\t\t_addMintingOffer(erc721Address_, rangeIndexes[i], splits[i], visibility[i], nodeAddress_);\n\t\t}\n\t}\n\n\t/// @notice This function allow us to add a new minting offer\n\t/// @dev \tThis function requires that account has the role of `CREATOR`\n\t/// @dev \tThis function requires that the marketplace is defined as MINTER\n\t/// @dev \tThis function requires that the range is available to create a new offer\n\t/// @param erc721Address_ Contains the address of the minter marketplace contract\n\t/// @param rangeIndex_ Contains the index location of the range where the offer will be placed\n\t/// @param splits Contains the shares and address to pay when the offer is succesfull \n\t/// @param visible_ Contains a boolean to set if the offer is public or not \n\t/// @param nodeAddress_ Contains address of the node where the offer was placed\n\tfunction _addMintingOffer(\n\t\taddress erc721Address_,\n\t\tuint rangeIndex_,\n\t\tfeeSplits[] memory splits,\n\t\tbool visible_,\n\t\taddress nodeAddress_\n\t) internal checkMinterRole(erc721Address_) offerDoesntExist(erc721Address_, rangeIndex_) {\n\t\t_checkCreatorRole(erc721Address_);\n\t\tmintingOffer storage newOffer = s.mintingOffers.push();\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(erc721Address_).rangeInfo(rangeIndex_);\n\t\trequire(rangeData.mintableTokens > 0, \"Minter Marketplace: Offer doesn't have tokens available!\");\n\t\tnewOffer.erc721Address = erc721Address_;\n\t\tnewOffer.nodeAddress = nodeAddress_;\n\t\tnewOffer.rangeIndex = rangeIndex_;\n\t\tnewOffer.visible = visible_;\n\t\tif (rangeData.rangePrice > 0) {\n\t\t\tuint totalPercentage = s.nodeFee + s.treasuryFee;\n\t\t\tuint totalFunds = rangeData.rangePrice * totalPercentage / (100 * s.decimalPow);\n\t\t\tfor (uint i = 0; i < splits.length; i++) {\n\t\t\t\trequire(!isContract(splits[i].recipient), \"Minter Marketplace: Contracts can't be recipients of the splits\");\n\t\t\t\tuint splitForPercentage = rangeData.rangePrice * splits[i].percentage / (100 * s.decimalPow);\n\t\t\t\trequire(\n\t\t\t\t\tsplitForPercentage > 0,\n\t\t\t\t\t\"Minter Marketplace: A percentage on the array will result in an empty transfer\"\n\t\t\t\t);\n\t\t\t\ttotalFunds += splitForPercentage;\n\t\t\t\ttotalPercentage += splits[i].percentage;\n\t\t\t\tnewOffer.fees.push(splits[i]);\n\t\t\t}\n\t\t\trequire(totalPercentage == (100 * s.decimalPow), \"Minter Marketplace: Fees don't add up to 100%\");\n\t\t\trequire(totalFunds == rangeData.rangePrice, \"Minter Marketplace: Current fee configuration will result in missing funds\");\n\t\t}\n\t\ts.addressToOffers[erc721Address_].push(s.mintingOffers.length - 1);\n\t\ts.addressToRangeOffer[erc721Address_][rangeIndex_] = s.mintingOffers.length - 1;\n\t\temit AddedMintingOffer(erc721Address_, rangeIndex_, rangeData.rangeName, rangeData.rangePrice, splits.length, visible_, s.mintingOffers.length - 1);\n\t}\n\n\t/// @notice This function allow us to update the parameters of a minting offers\n\t/// @dev \tThis function requires that the mintingOfferExists points to an valid offer  \n\t/// @param \tmintingOfferId_  Contains index location of the minting offer\n\t/// @param \tsplits_ \t\t Contains the shares and address to pay when the offer is succesfull \n\t/// @param \tvisible_    \t Contains a boolean to set if the offer is public or not \n\tfunction updateMintingOffer (\n\t\tuint mintingOfferId_,\n\t\tfeeSplits[] memory splits_,\n\t\tbool visible_\n\t) external mintingOfferExists(mintingOfferId_) {\n\t\t_updateMintingOffer(mintingOfferId_, splits_, visible_);\n\t}\n\n\t/// @notice This function allow us to update the parameters of a minting offers \n\t/// @param \tmintingOfferId_  Contains index location of the minting offer\n\t/// @param \tsplits_ \t\t Contains the shares and address to pay when the offer is succesfull \n\t/// @param \tvisible_         Contains a boolean to set if the offer is public or not \n\tfunction _updateMintingOffer (\n\t\tuint mintingOfferId_,\n\t\tfeeSplits[] memory splits_,\n\t\tbool visible_\n\t) internal {\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[mintingOfferId_];\n\t\t_checkCreatorRole(selectedOffer.erc721Address);\n\t\trequire(\n\t\t\thasMinterRole(selectedOffer.erc721Address),\n\t\t\t\"Minter Marketplace: This Marketplace isn't a Minter!\"\n\t\t);\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tuint totalPercentage = s.nodeFee + s.treasuryFee;\n\t\tdelete selectedOffer.fees;\n\t\tfor (uint i = 0; i < splits_.length; i++) {\n\t\t\trequire(!isContract(splits_[i].recipient), \"Minter Marketplace: Contracts can't be recipients of fees\");\n\t\t\trequire(\n\t\t\t\trangeData.rangePrice * splits_[i].percentage / (100 * s.decimalPow) > 0,\n\t\t\t\t\"Minter Marketplace: A percentage on the array will result in an empty transfer\"\n\t\t\t);\n\t\t\ttotalPercentage += splits_[i].percentage;\n\t\t\tselectedOffer.fees.push(splits_[i]);\n\t\t}\n\t\trequire(totalPercentage == (100 * s.decimalPow), \"Minter Marketplace: Fees don't add up to 100%\");\n\t\tselectedOffer.visible = visible_;\n\t\temit UpdatedMintingOffer(\n\t\t\tselectedOffer.erc721Address,\n\t\t\tselectedOffer.rangeIndex,\n\t\t\tselectedOffer.fees.length,\n\t\t\tselectedOffer.visible,\n\t\t\tmintingOfferId_\n\t\t);\n\t}\n\n\t/// @notice This function allow us to buy a minting offers\n\t/// @dev \tThis function requires that the mintingOfferExists points to an valid offer  \n\t/// @param \tofferIndex_  Contains index location of the offer\n\t/// @param \ttokenIndex_  Contains the id of the tokens that we want to mint\n\tfunction buyMintingOffer(uint offerIndex_, uint tokenIndex_) public mintingOfferExists(offerIndex_) payable {\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[offerIndex_];\n\t\trequire(selectedOffer.visible, \"Minter Marketplace: This offer is not ready to be sold!\");\n\t\trequire(hasMinterRole(selectedOffer.erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tif (rangeData.rangePrice > 0) {\n\t\t\trequire(rangeData.rangePrice <= msg.value, \"Minter Marketplace: Insufficient funds!\");\n\t\t\tif (msg.value - rangeData.rangePrice > 0) {\n\t\t\t\tpayable(msg.sender).transfer(msg.value - rangeData.rangePrice);\n\t\t\t}\n\t\t\tuint totalTransferred = rangeData.rangePrice * (s.nodeFee + s.treasuryFee) / (100 * s.decimalPow);\n\t\t\tpayable(selectedOffer.nodeAddress).transfer(rangeData.rangePrice * s.nodeFee / (100 * s.decimalPow));\n\t\t\tpayable(s.treasuryAddress).transfer(rangeData.rangePrice * s.treasuryFee / (100 * s.decimalPow));\n\t\t\tuint auxMoneyToBeSent;\n\t\t\tfor (uint i = 0; i < selectedOffer.fees.length; i++) {\n\t\t\t\tauxMoneyToBeSent = rangeData.rangePrice * selectedOffer.fees[i].percentage / (100 * s.decimalPow);\n\t\t\t\ttotalTransferred += auxMoneyToBeSent;\n\t\t\t\tpayable(selectedOffer.fees[i].recipient).transfer(auxMoneyToBeSent);\n\t\t\t}\n\t\t\trequire(totalTransferred == rangeData.rangePrice, \"Minter Marketplace: Error transferring funds!\");\n\t\t}\n\t\t_buyMintingOffer(selectedOffer.erc721Address, selectedOffer.rangeIndex, tokenIndex_, msg.sender);\n\t}\n\n\t/// @notice This function allow us to buy a collection of minting offers\n\t/// @dev \tThis function requires that the mintingOfferExists points to an valid offer  \n\t/// @param \tofferIndex_  \tContains index location of the offer\n\t/// @param \ttokenIndexes\tContains the collection of tokens that we want to mint\n\t/// @param \trecipients \t\tContains the collection of addresses that will receive\n\tfunction buyMintingOfferBatch(\n\t\tuint offerIndex_,\n\t\tuint[] calldata tokenIndexes,\n\t\taddress[] calldata recipients\t\t\n\t) external mintingOfferExists(offerIndex_) payable {\n\t\trequire(tokenIndexes.length > 0, \"Minter Marketplace: No tokens sent!\");\n\t\trequire(tokenIndexes.length == recipients.length, \"Minter Marketplace: Tokens and Addresses should have the same length\");\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[offerIndex_];\n\t\trequire(selectedOffer.visible, \"Minter Marketplace: This offer is not ready to be sold!\");\n\t\trequire(hasMinterRole(selectedOffer.erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\n\t\t(IRAIR721.range memory rangeData,) = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\n\t\tuint i;\n\t\tif (rangeData.rangePrice > 0) {\n\t\t\trequire((rangeData.rangePrice * tokenIndexes.length) <= msg.value, \"Minter Marketplace: Insufficient funds!\");\n\t\t\tif (msg.value - (rangeData.rangePrice * tokenIndexes.length) > 0) {\n\t\t\t\tpayable(msg.sender).transfer(msg.value - (rangeData.rangePrice * tokenIndexes.length));\n\t\t\t}\n\t\t\tuint totalTransferred = (rangeData.rangePrice * tokenIndexes.length) * (s.nodeFee + s.treasuryFee) / (100 * s.decimalPow);\n\t\t\tpayable(selectedOffer.nodeAddress).transfer((rangeData.rangePrice * tokenIndexes.length) * s.nodeFee / (100 * s.decimalPow));\n\t\t\tpayable(s.treasuryAddress).transfer((rangeData.rangePrice * tokenIndexes.length) * s.treasuryFee / (100 * s.decimalPow));\n\t\t\tuint auxMoneyToBeSent;\n\t\t\tfor (i = 0; i < selectedOffer.fees.length; i++) {\n\t\t\t\tauxMoneyToBeSent = (rangeData.rangePrice * tokenIndexes.length) * selectedOffer.fees[i].percentage / (100 * s.decimalPow);\n\t\t\t\ttotalTransferred += auxMoneyToBeSent;\n\t\t\t\tpayable(selectedOffer.fees[i].recipient).transfer(auxMoneyToBeSent);\n\t\t\t}\n\t\t\trequire(totalTransferred == (rangeData.rangePrice * tokenIndexes.length), \"Minter Marketplace: Error transferring funds!\");\n\t\t}\n\t\tfor (i = 0; i < tokenIndexes.length; i++) {\n\t\t\t_buyMintingOffer(selectedOffer.erc721Address, selectedOffer.rangeIndex, tokenIndexes[i], recipients[i]);\n\t\t}\n\t}\n\n\t/// @notice This function is in charge of buying a desired minting offer \n\t/// @param erc721Address  Contains the address where the offer is located\n\t/// @param rangeIndex\t  Contains the index location of the range where the token is \n\t/// @param tokenIndex  \t  Contains the index location of the token to buy \n\t/// @param recipient   \t  Contains the address of the recipient of the token\n\tfunction _buyMintingOffer(address erc721Address, uint rangeIndex, uint tokenIndex, address recipient) internal {\n\t\tIRAIR721(erc721Address).mintFromRange(recipient, rangeIndex, tokenIndex);\n\t\temit MintedToken(erc721Address, rangeIndex, tokenIndex, recipient);\n\t}\n}"
    },
    "contracts/Marketplace/MarketplaceDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\n// Parent classes\nimport './AppStorage.sol';\nimport '../diamondStandard/Diamond.sol';\n\n/// @title  RAIR ERC721 Marketplace Diamond\n/// @notice Handles the trading of ERC721 RAIR Tokens\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice this contract is inheriting from Diamond & AccessControlAppStorageEnumerableMarket\ncontract MarketplaceDiamond is Diamond, AccessControlAppStorageEnumerableMarket {\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\n\t\ts.decimals = 3;\n\t\ts.decimalPow = 10**3;\n\t\ts.nodeFee = 1 * s.decimalPow;\n\t\ts.treasuryFee = 9 * s.decimalPow;\n\t\t_setRoleAdmin(MAINTAINER, MAINTAINER);\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n\t\t_grantRole(MAINTAINER, msg.sender);\n\t}\n}"
    },
    "contracts/tokens/forTest/RAIR-ERC777.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\n\n/// @title  RAIR 777 for testing\n/// @notice This contract is used for testing purpouse\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from ERC777\ncontract RAIR777 is ERC777 {\n    constructor(uint256 initialSupply, address[] memory _defaultOperators )\n        ERC777(\"RAIR\", \"RAIR\", _defaultOperators)\n    {\n        _mint(msg.sender, initialSupply, \"\", \"\");\n    }\n\n    receive() external payable {}\n}"
    },
    "contracts/tokens/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\n/// @title  IERC2981 interface contract\n/// @notice This contracts contains all th logic and function for\n///         the correct implementation of the NFT Royalty Standard\ninterface IERC2981 {\n    /// ERC165 bytes to add to interface array - set in parent contract\n    /// implementing this standard\n    ///\n    /// bytes4(keccak256(\"royaltyInfo(uint256,uint256,bytes)\")) == 0xc155531d\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0xc155531d;\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    /// @param _tokenId - the NFT asset queried for royalty information\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n    /// @return receiver - address of who should be sent the royalty payment\n    /// @return royaltyAmount - the royalty payment amount for _value sale price\n    function royaltyInfo(\n    \tuint256 _tokenId,\n    \tuint256 _salePrice)\n    external returns (\n    \taddress receiver,\n    \tuint256 royaltyAmount);\n\n    /// @notice Informs callers that this contract supports ERC2981\n    /// @dev    If `_registerInterface(_INTERFACE_ID_ERC2981)` is called\n    ///         in the initializer, this should be automatic\n    /// @param  interfaceID The interface identifier, as specified in ERC-165\n    /// @return `true` if the contract implements\n    ///         `_INTERFACE_ID_ERC2981` and `false` otherwise\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}"
    },
    "contracts/tokens/RAIR Token Facets/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\nimport '../../common/AccessControl.sol';\n\nstruct range {\n\tuint rangeStart;\n\tuint rangeEnd;\n\tuint tokensAllowed;\n\tuint mintableTokens;\n\tuint lockedTokens;\n\tuint rangePrice;\n\tstring rangeName;\n}\n\nstruct product {\n\tuint startingToken;\n\tuint endingToken;\n\tuint mintableTokens;\n\tstring name;\n\tuint[] rangeList;\n}\n\nstruct AppStorage721 {\n\t// ERC721\n\tstring _name;\n\tstring _symbol;\n\tmapping(uint256 => address) _owners;\n\tmapping(address => uint256) _balances;\n\tmapping(uint256 => address) _tokenApprovals;\n\tmapping(address => mapping(address => bool)) _operatorApprovals;\n\t// ERC721 Enumerable\n\tmapping(address => mapping(uint256 => uint256)) _ownedTokens;\n\tmapping(uint256 => uint256) _ownedTokensIndex;\n\tuint256[] _allTokens;\n\tmapping(uint256 => uint256) _allTokensIndex;\n\t// Access Control Enumerable\n\tmapping(bytes32 => RoleData) _roles;\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\n\t// App\n\tstring baseURI;\n\taddress factoryAddress;\n\tuint16 royaltyFee;\n\tproduct[] products;\n\trange[] ranges;\n\tmapping(uint => uint) tokenToProduct;\n\tmapping(uint => uint) tokenToRange;\n\tmapping(uint => string) uniqueTokenURI;\n\tmapping(uint => string) productURI;\n\tmapping(uint => bool) appendTokenIndexToProductURI;\n\tbool appendTokenIndexToBaseURI;\n\tmapping(uint => uint[]) tokensByProduct;\n\tstring contractMetadataURI;\n\tmapping(uint => uint) rangeToProduct;\n\tmapping(uint => bool) _minted;\n\t// August 2022 - Metadata File Extension Update\n\tmapping(uint => string) rangeURI;\n\tmapping(uint => bool) appendTokenIndexToRangeURI;\n\tstring _metadataExtension;\n\t// Always add new variables at the end of the struct\n}\n\nlibrary LibAppStorage721 {\n\t/// @notice this funtion set the storage of the diamonds 721 contracts \n\tfunction diamondStorage() internal pure\treturns (AppStorage721 storage ds) {\n\t\tassembly {\n\t\t\tds.slot := 0\n\t\t}\n\t}\n}\n\n/// @title  This is contract to manage the access control of the RAIR token facet\n/// @notice You can use this contract to administrate roles of the app market\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from Context\ncontract AccessControlAppStorageEnumerable721 is Context {\n\tAppStorage721 internal s;\n\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\n\t/// @notice This event stores in the blockchain when we change an admin role\n    /// @param  role Contains the role we want to update\n    /// @param  previousAdminRole contains the previous status of the role\n\t/// @param  newAdminRole contains the new status of the role\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\t/// @notice This event stores in the blockchain when we grant a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to grant the role\n\t/// @param  sender contains the address that is changing the role of the account\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\t/// @notice This event stores in the blockchain when we revoke a role\n    /// @param  role Contains the role we want to update\n    /// @param  account contains the address that we want to revoke the role\n\t/// @param  sender contains the address that is changing the role of the account\n\tevent RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n\tmodifier onlyRole(bytes32 role) {\n\t\t_checkRole(role, _msgSender());\n\t\t_;\n\t}\n\n\t/// @notice Allow us to renounce to a role\n\t/// @dev \tCurrently you can only renounce to your own roles\n\t/// @param \trole Contains the role to remove from our account\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction renounceRole(bytes32 role, address account) public {\n\t\trequire(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\t\t_revokeRole(role, account);\n\t}\n\n\t/// @notice Allow us to grant a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to grant\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n\t\t_grantRole(role, account);\n\t}\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @dev \tThis function is only available to an account with an Admin role\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\n\t\t_revokeRole(role, account);\n\t}\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n\tfunction _checkRole(bytes32 role, address account) internal view {\n\t\tif (!hasRole(role, account)) {\n\t\t\trevert(\n\t\t\t\tstring(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\t\"AccessControl: account \",\n\t\t\t\t\t\tStrings.toHexString(uint160(account), 20),\n\t\t\t\t\t\t\" is missing role \",\n\t\t\t\t\t\tStrings.toHexString(uint256(role), 32)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/// @notice Allow us to check the if and account has a selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \taccount Contains the account address thay we want to verify\n\t/// @return bool that indicates if an account has or not a role\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\n\t\treturn s._roles[role].members[account];\n\t}\n\n\t/// @notice Allow us to check the admin role that contains a role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return bytes that indicates if an account has or not an admin role\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\n\t\treturn s._roles[role].adminRole;\n\t}\n\n\t/// @notice Allow us to check the address of an indexed position for the role list\n\t/// @param \trole Contains the role that we want to verify\n\t/// @param \tindex Contains the indexed position to verify inside the role members list\n\t/// @return address that indicates the address indexed in that position\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\n\t\treturn s._roleMembers[role].at(index);\n\t}\n\n\t/// @notice Allow us to check total members that has an selected role\n\t/// @param \trole Contains the role that we want to verify\n\t/// @return uint256 that indicates the total accounts with that role\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\n\t\treturn s._roleMembers[role].length();\n\t}\n\n\t/// @notice Allow us to modify a rol and set it as an admin role\n\t/// @param \trole Contains the role that we want to modify\n\t/// @param \tadminRole Contains the admin role that we want to set\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\n\t\ts._roles[role].adminRole = adminRole;\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\n\t}\n\n\t/// @notice Allow us to revoke a role to an account\n\t/// @param \trole Contains the role that we want to revoke\n\t/// @param \taccount Contains the account that has the role we want to update\n\tfunction _revokeRole(bytes32 role, address account) internal {\n\t\tif (hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t\ts._roleMembers[role].remove(account);\n\t\t}\n\t}\n\n\t/// @notice Allow us to grant a new role to an account\n\t/// @dev \tNotice that this function override the behavior of\n\t/// @dev \tthe _grantRole function inherited from AccessControlEnumerable\n\t/// @param \trole Contains the facet addresses and function selectors\n    /// @param \taccount Contains the facet addresses and function selectors\n\tfunction _grantRole(bytes32 role, address account) internal {\n\t\tif (!hasRole(role, account)) {\n\t\t\ts._roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t\ts._roleMembers[role].add(account);\n\t\t}\n\t}\n}"
    },
    "contracts/tokens/RAIR Token Facets/ERC721Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\nimport './AppStorage.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\n/// @title  This is contract to manage the ERC721 NFT facet \n/// @notice You can use this contract to administrate ranges, transfers & minting of the tokens\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721\ncontract ERC721Facet is AccessControlAppStorageEnumerable721 {\n\tusing Address for address;\n\n\tbytes32 public constant TRADER = keccak256(\"TRADER\");\n\tbytes32 public constant MINTER = keccak256(\"MINTER\");\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n\n\t/// @notice This event stores in the blockchain when a product is succesfully finished\n    /// @param  productIndex Contains the position where the product was indexed\n\tevent ProductCompleted(uint indexed productIndex);\n\t/// @notice This event stores in the blockchain when a range is succesfully established\n    /// @param  rangeIndex Contains the position where the range was indexed \n\t/// @param  productIndex Contains the indexed location for the product\n\tevent RangeCompleted(uint indexed rangeIndex, uint productIndex);\n\t/// @notice This event stores in the blockchain when a trading is unlocked\n\t/// @param  rangeIndex Contains the position where the range is indexed\n    /// @param  from Containt the date of begining of the range\n\t/// @param  to Contain the date of end for the range\n\tevent TradingUnlocked(uint indexed rangeIndex, uint from, uint to);\n\t/// @notice This event stores in the blockchain when a trasfer is made\n    /// @param  from Contains the sender of the transaction\n\t/// @param  to Contains the destiny address of the transaction\n\t/// @param  tokenId Contains the id of the token to transfer\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\t/// @notice This event stores in the blockchain when an user is approved to move a token\n    /// @param  owner Contains the address of the owner of the tokens\n\t/// @param  approved Contains the address of the user approved for move the token\n\t/// @param \ttokenId Contains the id of the transfered token\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\t/// @notice This event stores in the blockchain when a owner is approved to move all the tokens\n    /// @param  owner \t\tContains the address of the owner of the tokens\n\t/// @param  operator \tContains the address of the user approved for move all the tokens\n\t/// @param\tapproved \tBoolean flag to approve or disapprove the operator\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\t\n\t/// @notice This function allow us to check the name of the token\n\t/// @return string with the name of the token\n\tfunction name() public view returns (string memory) {\n\t\treturn s._name;\n\t}\n\n\t/// @notice This function allow us to check the symbol of the token\n\t/// @return string with the symbol of the token\n\tfunction symbol() public view returns (string memory) {\n\t\treturn s._symbol;\n\t}\n\n\t/// @notice This function allow us to check the balance of an account\n\t/// @param \towner Contains the address of the owner of tokens that we want to verify\n\t/// @return uint256  with the total of the owned tokens\n\tfunction balanceOf(address owner) public view returns (uint256) {\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn s._balances[owner];\n\t}\n\n\t/// @notice This function allow us to check the balance of an account for a specific indexed token \n\t/// @param \towner Contains the address of the owner of tokens that we want to verify\n\t/// @param \tindex Contains the index of the list of owned token that we want to check\n\t/// @return uint256 which contains the owned token \n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n\t\trequire(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n\t\treturn s._ownedTokens[owner][index];\n\t}\n\n\t/// @notice This function allow us to check the total amount of tokens\n\t/// @return uint256 which contains the total amount of tokens \n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn s._allTokens.length;\n\t}\n\n\t/// @notice This function allow us to verify the token indexed in a selected position \n\t/// @param \tindex Contains the index position that we want to check\n\t/// @return uint256 which contains the token indexed in that position \n\tfunction tokenByIndex(uint256 index) public view returns (uint256) {\n\t\trequire(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n\t\treturn s._allTokens[index];\n\t}\n\n\t/// @notice Queries if an operator can act on behalf of an owner on all of their tokens\n\t/// @dev Overrides the OpenZeppelin standard by allowing anyone with the TRADER role to transfer tokens\n\t/// @param \towner \t\tOwner of the tokens.\n\t/// @param \toperator \tOperator of the tokens.\n\t/// @return bool \t\tNotify if the operator is approved or not for move all the tokens\n\tfunction isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n\t\treturn (hasRole(TRADER, operator) || s._operatorApprovals[owner][operator]);\n\t}\n\n\t/// @notice This function returns immediately next token without owner in the range\n\t/// @param \trangeIndex Contains index of the range that we want to veify\n\t/// @return uint which containts the immediately next token absent of owner\n\tfunction nextMintableTokenInRange(uint rangeIndex) public view returns (uint) {\n\t\trequire(s.ranges.length > rangeIndex, \"RAIR ERC721 Ranges: Range does not exist\");\n\t\trange memory selectedRange = s.ranges[rangeIndex];\n\t\tproduct memory selectedProduct = s.products[s.rangeToProduct[rangeIndex]];\n\t\tfor (uint i = selectedRange.rangeStart; i < selectedRange.rangeEnd; i++) {\n\t\t\tif (!_exists(selectedProduct.startingToken + i)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\trequire(false, 'RAIR ERC721: There are no tokens available for minting');\n\t}\n\n\t/// @notice This function allow us to mint a token form a specific range\n\t/// @param to Contains the address that will own the minted token\n\t/// @param rangeId Contains the id of the range that we want to use for minting \n\t/// @param indexInRange Contains the position where the minted token will be indexed\n\tfunction _mintFromRange(address to, uint rangeId, uint indexInRange) internal {\n\t\trequire(s.ranges.length > rangeId, \"RAIR ERC721: Range does not exist\");\n\t\trange storage selectedRange = s.ranges[rangeId];\n\t\tproduct storage selectedProduct = s.products[s.rangeToProduct[rangeId]];\n\t\trequire(selectedProduct.mintableTokens > 0, 'RAIR ERC721: Cannot mint more tokens from this product!');\n\t\trequire(selectedRange.mintableTokens > 0, 'RAIR ERC721: Cannot mint more tokens from this range!');\n\t\trequire(selectedRange.tokensAllowed > 0, 'RAIR ERC721: Not allowed to mint more tokens from this range!');\n\t\trequire(indexInRange >= selectedRange.rangeStart && indexInRange <= selectedRange.rangeEnd, \"RAIR ERC721: Invalid token index\");\n\t\t_safeMint(to, selectedProduct.startingToken + indexInRange, '');\n\t\t\n\t\tif (selectedRange.tokensAllowed > 0) {\n\t\t\tselectedRange.tokensAllowed--;\n\t\t}\n\t\tif (selectedRange.mintableTokens > 0) {\n\t\t\tselectedRange.mintableTokens--;\n\t\t\tif (selectedRange.mintableTokens == 0) {\n\t\t\t\temit RangeCompleted(rangeId, s.rangeToProduct[rangeId]);\n\t\t\t}\n\t\t}\n\t\tif (selectedRange.lockedTokens > 0) {\n\t\t\tselectedRange.lockedTokens--;\n\t\t\tif (selectedRange.lockedTokens == 0) {\n\t\t\t\temit TradingUnlocked(rangeId, selectedRange.rangeStart, selectedRange.rangeEnd);\n\t\t\t}\n\t\t}\n\t\tif (selectedProduct.mintableTokens > 0) {\n\t\t\tselectedProduct.mintableTokens--;\n\t\t\tif (selectedProduct.mintableTokens == 0) {\n\t\t\t\temit ProductCompleted(s.rangeToProduct[rangeId]);\n\t\t\t}\n\t\t}\n\t\ts.tokenToProduct[selectedProduct.startingToken + indexInRange] = s.rangeToProduct[rangeId];\n\t\ts.tokenToRange[selectedProduct.startingToken + indexInRange] = rangeId;\n\t\ts.tokensByProduct[s.rangeToProduct[rangeId]].push(selectedProduct.startingToken + indexInRange);\n\t}\n\n\t/// @notice This function allow us to mint a token form a batch of ranges\n\t/// @param to Contains the address that will own the minted token\n\t/// @param rangeId Contains the id of the range that we want to use for minting \n\t/// @param indexInRange Contains array of ranges that will be used to index the minted NFT\n\tfunction mintFromRangeBatch(\n\t\taddress[] calldata to,\n\t\tuint rangeId,\n\t\tuint[] calldata indexInRange\n\t) external onlyRole(MINTER) {\n\t\trequire(to.length > 0, \"RAIR ERC721: Empty array\");\n\t\trequire(to.length == indexInRange.length, \"RAIR ERC721: Both arrays should have the same length\");\n\t\tfor (uint i = 0; i < to.length; i++) {\n\t\t\t_mintFromRange(to[i], rangeId, indexInRange[i]);\n\t\t}\n\t}\n\n\t/// @notice This function allow us to mint from a range\n\t/// @param to Contains the facet addresses and function selectors\n\t///\t@dev\tOnly an account with the `MINTER` role is available to use this function\n\t/// @param rangeId Contains the facet addresses and function selectors\n\t/// @param indexInRange Contains the facet addresses and function selectors\n\tfunction mintFromRange(address to, uint rangeId, uint indexInRange) external onlyRole(MINTER) {\n\t\t_mintFromRange(to, rangeId, indexInRange);\n\t}\n\n\t/// @notice This function allow us to check if an user is approved for spend the token or the owner \n\t/// @param spender Contains the addres which status and permision we want to validate\n\t/// @param tokenId Contains the id of the token that we want to spend\n\t/// @return bool with the status of true is the account has the owner or approved role\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\t\taddress owner = ownerOf(tokenId);\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n\t}\n\n\t/// @notice This function grants permision to an account for move one specific token\n\t/// @param to Contains the facet addresses and function selectors\n\t/// @param tokenId Contains the facet addresses and function selectors\n\tfunction approve(address to, uint256 tokenId) public {\n\t\taddress owner = ownerOf(tokenId);\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\n\n\t\trequire(\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\n\t\t);\n\n\t\t_approve(to, tokenId);\n\t}\n\n\t/// @notice This function grants permision to an account for move any token\n\t/// @param operator Contains the address with authorization to move the tokens\n\t/// @param approved Contains the status of approved or not for the operator\n\tfunction setApprovalForAll(address operator, bool approved) public {\n\t\t_setApprovalForAll(_msgSender(), operator, approved);\n\t}\n\n\t/// @notice This function grants permision to an account for move any token\n\t/// @param owner Contains the address of the owner of the token \n\t/// @param operator Contains the address with authorization to move the tokens\n\t/// @param approved Contains the status of approved or not for the operator\n\tfunction _setApprovalForAll(\n\t\taddress owner,\n\t\taddress operator,\n\t\tbool approved\n\t) internal virtual {\n\t\trequire(owner != operator, \"ERC721: approve to caller\");\n\t\ts._operatorApprovals[owner][operator] = approved;\n\t\temit ApprovalForAll(owner, operator, approved);\n\t}\n\n\t/// @notice This function grants permision to an account for move one specific token\n\t/// @param to Contains the address that we want to grant the permision fot the token\n\t/// @param tokenId Contains the id of the token to be approved\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\n\t\ts._tokenApprovals[tokenId] = to;\n\t\temit Approval(ownerOf(tokenId), to, tokenId);\n\t}\n\n\t/// @notice This function allow us to see the address approved for an specific token\n\t/// @param tokenId Contains the token of the id to be added to the account\n\t/// @return address which has the authorization to move the token\n\tfunction getApproved(uint256 tokenId) public view returns (address) {\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\t\treturn s._tokenApprovals[tokenId];\n\t}\n\t\n\t/// @notice This function allow us to know if the token exist or not\n\t/// @param tokenId Contains the id of the token that we want to verify\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn s._owners[tokenId] != address(0);\n\t}\n\n\t/// @notice This function allow us to mint a token\n\t/// @param to Contains the address which will mint the token\n\t/// @param tokenId constains the indexed identification of the token \n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\n\t\t_safeMint(to, tokenId, \"\");\n\t}\n\n\t/// @notice This function allow us to mint a token\n\t/// @param to Contains the address which will mint the token\n\t/// @param tokenId Constains the indexed identification of the token\n\t/// @param _data Constains the additional message fot the receiver of the token\n\tfunction _safeMint(\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) internal virtual {\n\t\t_mint(to, tokenId);\n\t\trequire(\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\n\t\t);\n\t}\n\n\t/// @notice This function allow us to mint \n\t/// @param to Contains the address which will mint the token\n\t/// @param tokenId constains the indexed identification of the token \n\tfunction _mint(address to, uint256 tokenId) internal virtual {\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\n\n\t\ts._balances[to] += 1;\n\t\ts._owners[tokenId] = to;\n\t\ts._minted[tokenId] = true;\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\t/// @notice This functions allow us to know the address that owns the token\n\t/// @param tokenId Contains the facet addresses and function selectors\n\t/// @return address Which contains the owner of the token \n\tfunction ownerOf(uint256 tokenId) public view returns (address) {\n\t\taddress owner = s._owners[tokenId];\n\t\trequire(owner != address(0), \"ERC721: owner query for nonexistent token\");\n\t\treturn owner;\n\t}\n\n\t/// @notice Hook being called before every transfer\n\t/// @dev\tTransfer locking happens here!\n\t/// @param\t_from\t\tToken's original owner\n\t/// @param\t_to\t\t\tToken's new owner\n\t/// @param\t_tokenId\tToken's ID\n\tfunction _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal {\n\t\t// If it's not minting or burning \n\t\tif (_from != address(0) && _to != address(0)) {\n\t\t\t_checkRole(TRADER, msg.sender);\n\t\t\trequire(s.ranges[s.tokenToRange[_tokenId]].lockedTokens == 0, \"RAIR ERC721: Cannot transfer from a locked range!\");\n\t\t}\n\t\tif (_from == address(0)) {\n\t\t\t_addTokenToAllTokensEnumeration(_tokenId);\n\t\t} else if (_from != _to) {\n\t\t\t_removeTokenFromOwnerEnumeration(_from, _tokenId);\n\t\t}\n\t\tif (_to == address(0)) {\n\t\t\t_removeTokenFromAllTokensEnumeration(_tokenId);\n\t\t} else if (_to != _from) {\n\t\t\t_addTokenToOwnerEnumeration(_to, _tokenId);\n\t\t}\n\t\t//require(hasRole(TRADER, _from), 'RAIR ERC721: Transfers cannot be made outside RAIR marketplaces!');\n\t}\n\n\t/**\n\t * @dev   Private function to add a token to this extension's ownership-tracking data structures.\n\t * @param to address representing the new owner of the given token ID\n\t * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\t */\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n\t\tuint256 length = balanceOf(to);\n\t\ts._ownedTokens[to][length] = tokenId;\n\t\ts._ownedTokensIndex[tokenId] = length;\n\t}\n\n\t/**\n\t * @dev   Private function to add a token to this extension's token tracking data structures.\n\t * @param tokenId uint256 ID of the token to be added to the tokens list\n\t */\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n\t\ts._allTokensIndex[tokenId] = s._allTokens.length;\n\t\ts._allTokens.push(tokenId);\n\t}\n\n\t/// @notice This function will remove a token from the owner account \n\t/**\n\t * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n\t * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n\t * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n\t * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n\t * @param from address representing the previous owner of the given token ID\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\t */\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n\t\t// To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n\t\t// then delete the last slot (swap and pop).\n\n\t\tuint256 lastTokenIndex = balanceOf(from) - 1;\n\t\tuint256 tokenIndex = s._ownedTokensIndex[tokenId];\n\n\t\t// When the token to delete is the last token, the swap operation is unnecessary\n\t\tif (tokenIndex != lastTokenIndex) {\n\t\t\tuint256 lastTokenId = s._ownedTokens[from][lastTokenIndex];\n\n\t\t\ts._ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n\t\t\ts._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\t\t}\n\n\t\t// This also deletes the contents at the last position of the array\n\t\tdelete s._ownedTokensIndex[tokenId];\n\t\tdelete s._ownedTokens[from][lastTokenIndex];\n\t}\n\n\t/// @notice This function will remove a token for the extension's data structures\n\t/**\n\t * @dev Private function to remove a token from this extension's token tracking data structures.\n\t * This has O(1) time complexity, but alters the order of the _allTokens array.\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list\n\t */\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n\t\t// To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n\t\t// then delete the last slot (swap and pop).\n\n\t\tuint256 lastTokenIndex = s._allTokens.length - 1;\n\t\tuint256 tokenIndex = s._allTokensIndex[tokenId];\n\n\t\t// When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n\t\t// rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n\t\t// an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n\t\tuint256 lastTokenId = s._allTokens[lastTokenIndex];\n\n\t\ts._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n\t\ts._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n\t\t// This also deletes the contents at the last position of the array\n\t\tdelete s._allTokensIndex[tokenId];\n\t\ts._allTokens.pop();\n\t}\n\n\t/// @notice This function is used to transfer tokens from an account to another \n\t/// @param  from Contains the address of the owner of the token\n\t/// @param  to Contains the address of the receiver of the token\n\t/// @param  tokenId Contains the ID of the token to transfer\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public {\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\t/// @notice This function grant permision to approved accounts to transfer a token \n\t/**\n\t * @dev \tSee {IERC721-safeTransferFrom}.\n\t */\n\t/// @param  from \tContains the address of the owner of the token\n\t/// @param  to \t\tContains the address of the receiver of the token\n\t/// @param  tokenId\tContains the ID of the token to transfer\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\t/// @notice This function grant permision to approved accounts to transfer a token \n\t/**\n\t * @dev \tSee {IERC721-safeTransferFrom}.\n\t */\n\t/// @param  from \tContains the address of the owner of the token\n\t/// @param  to \t\tContains the address of the receiver of the token\n\t/// @param  tokenId\tContains the ID of the token to transfer\n\t/// @param  _data \tContains any adicional info or massage\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) public {\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\t\t_safeTransfer(from, to, tokenId, _data);\n\t}\n\n\t/// @notice This funtion allow us to safetely transfer a token to a valid recipient \n\t/**\n\t * @dev \tSafely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n\t *\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\t/// @param from \tContains the address of the owner of the token\n\t/// @param to \t\tContains the address of the receiver of the token\n\t/// @param tokenId  Contains the ID of the token to transfer\n\t/// @param _data\tContains any adicional info or massage\n\tfunction _safeTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) internal {\n\t\t_transfer(from, to, tokenId);\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n\t}\n\n\t/// @notice This function is use to trasfer a owned token to a selected addresss\n\t/**\n\t * @dev \tTransfers `tokenId` from `from` to `to`.\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\t/// @param  from \tContains the address of the owner of the token\n\t/// @param  to \t\tContains the address of the receiver of the token\n\t/// @param  tokenId  Contains the ID of the token to transfer\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal {\n\t\trequire(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\t// Clear approvals from the previous owner\n\t\t_approve(address(0), tokenId);\n\n\t\ts._balances[from] -= 1;\n\t\ts._balances[to] += 1;\n\t\ts._owners[tokenId] = to;\n\n\t\temit Transfer(from, to, tokenId);\n\t}\n\n\t/// @param from \tContains the address of the sender\n\t/// @param to \t\tContains the address of the receiver\n\t/// @param tokenId  Contains the ID of the token to send\n\t/// @param _data \tContains any adicional info or massage \n\t/// @return bool \tThat show us if the transaction was successful or not\n\tfunction _checkOnERC721Received(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) private returns (bool) {\n\t\tif (to.isContract()) {\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\n\t\t\t} catch (bytes memory reason) {\n\t\t\t\tif (reason.length == 0) {\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\n\t\t\t\t} else {\n\t\t\t\t\tassembly {\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n}"
    },
    "contracts/tokens/RAIR Token Facets/ProductFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11;\n\nimport './AppStorage.sol';\n\n/// @title  RAIR Product facet contract\n/// @notice You can use this contract to manage information about the token and the products  \n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721\ncontract RAIRProductFacet is AccessControlAppStorageEnumerable721 {\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n\n\t/// @notice This event stores in the blockchain when a collection is correctly created\n    /// @param  collectionIndex Contains the unique id that will be indexed for the collection\n\t/// @param  collectionName Contains the name to identify the collection\n\t/// @param  startingToken Contains the selected NTF token to start the product \n\t/// @param  collectionLength Contains the total of tokens that we want the product to have\n\tevent CreatedCollection(uint indexed collectionIndex, string collectionName, uint startingToken, uint collectionLength);\n\n\t/// @notice Verifies that the product exists\n\t/// @param\tcollectionId\tCollection to verify\n\tmodifier collectionExists(uint collectionId) {\n\t\trequire(s.products.length > collectionId, \"RAIR ERC721: Collection does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice Verifies that the range exists\n\t/// @param\trangeID\tRange to verify\n\tmodifier rangeExists(uint rangeID) {\n\t\trequire(s.ranges.length > rangeID, \"RAIR ERC721: Range does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice Verifies that the token exists\n\t/// @param\ttokenIndex\tRange to verify\n\tmodifier tokenExists(uint tokenIndex) {\n\t\trequire(s._minted[tokenIndex], \"RAIR ERC721: Query for nonexistent token\");\n\t\t_;\n\t}\n\n\t/// @notice Wrapper for the validator, searching for the entire product\n\t/// @dev \tThis function require that the product exist\n\t/// @param\tfind\t\t\tAddress to search\n\t/// @param\tproductIndex\tCollection to verify\n\t/// @return bool \t\t\tFor the existence or not, of the token in the product \n\tfunction ownsTokenInProduct(address find, uint productIndex) public view collectionExists(productIndex) returns (bool) {\n\t\tproduct storage selectedProduct = s.products[productIndex];\n\t\treturn _ownsTokenInsideRange(find, selectedProduct.startingToken, selectedProduct.endingToken);\n\t}\n\n\t/// @notice Wrapper for the validator, searching for the entire range\n\t/// @dev \tThis function require that the range exist \n\t/// @param\tfind\t\tAddress to search\n\t/// @param\trangeIndex\tRange to verify\n\t/// @return bool \t\tFor the existence or not, of the token in the range \n\tfunction ownsTokenInRange(address find, uint rangeIndex) public view rangeExists(rangeIndex) returns (bool) {\n\t\trange storage selectedRange = s.ranges[rangeIndex];\n\t\tuint startOfProduct = s.products[s.rangeToProduct[rangeIndex]].startingToken;\n\t\treturn _ownsTokenInsideRange(find, startOfProduct + selectedRange.rangeStart, startOfProduct + selectedRange.rangeEnd);\n\t}\n\n\t/// @notice Validates that an address owns at least one token inside a specified range\n\t/// @dev Loops through the range, don't use on non-view functions\n\t/// @param\tfind\tAddress to validate\n\t/// @param\tfrom\tRange start\n\t/// @param\tto\t\tRange end\n\t/// @return bool \tFor the existence or not, of the token inside the range \n\tfunction _ownsTokenInsideRange(address find, uint from, uint to) internal view returns (bool) {\n\t\tfor (uint i = from; i < to; i++) {\n\t\t\tif (s._owners[i] == find) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/// @notice This function allow us to see the position of creation of a token\n\t/// @dev \tThis function require that the collection exist\n\t/// @param \tproductIndex_ Contains the index of the collection where is the token\n\t/// @param \ttokenIndex_   Contains the index of the token inside the collection\n\t/// @return uint\t\t  With the value of the token in that indexed position \n\tfunction tokenByProduct(uint productIndex_, uint tokenIndex_) public view collectionExists(productIndex_) returns (uint) {\n\t\treturn s.tokensByProduct[productIndex_][tokenIndex_];\n\t}\n\n\t/// @notice This function will search in a collection for a especific token and return its value\n\t/// @dev \tThis function require that the collection exist\\\n\t/// @param \tproductIndex_ Contains the index of the collection where is the token\n\t/// @param \ttokenIndex_   Contains the index of the token inside the collection\n\t/// @return uint\t\t  With the value of the token in that indexed position \n\tfunction productToToken(uint productIndex_, uint tokenIndex_) public view collectionExists(productIndex_) returns(uint) {\n\t\treturn s.products[productIndex_].startingToken + tokenIndex_;\n\t}\n\n\t/// @notice This function allow us to know the index of the collection that contains the token\n\t/// @dev \tThis function require that the token exist\n\t/// @param  tokenIndex_  Contains the index of the token inside the collection\n\t/// @return uint \t\t Return the ID of the collection \n\tfunction tokenToProductIndex(uint tokenIndex_) public view tokenExists(tokenIndex_) returns (uint) {\n\t\treturn tokenIndex_ - s.products[s.tokenToProduct[tokenIndex_]].startingToken;\n\t}\n\n\t/// @notice This function allow us to locaste the collection & range of a token \n\t/// @dev \tThis function require that the token exist\n\t/// @param \ttokenIndex_   Contains the index of the token which info we want to know \n\t/// @return productIndex  With the corresponding collection ID for the token\n\t/// @return rangeIndex\t  With the corresponding range of the collection \n\tfunction tokenToProduct(uint tokenIndex_) public view tokenExists(tokenIndex_) returns (uint productIndex, uint rangeIndex) {\n\t\tproductIndex = s.tokenToProduct[tokenIndex_];\n\t\trangeIndex = s.tokenToRange[tokenIndex_];\n\t}\n\n\t/// @notice\tReturns the number of products on the contract\n\t/// @dev\tUse with get product to list all of the products\n\t/// @return uint With the total of products\n\tfunction getProductCount() external view returns(uint) {\n\t\treturn s.products.length;\n\t}\n\n\t/// @notice This function allow us to check the information of a product\n\t/// @dev \tThis function require that the collection exist\n\t/// @param productIndex_ Contains the id of the product that we want to verify\n\t/// @return product which contain the information of the product\n\tfunction getProductInfo(uint productIndex_) external view collectionExists(productIndex_) returns (product memory) {\n\t\treturn s.products[productIndex_];\n\t}\n\n\t/// @notice This functions allow us to check is a token is owned by an account\n\t/// @param owner Contains address of the acount that we want to verify\n\t/// @param index Contains the position in the owned tokens list\n\t/// @return uint with the token that is owned by the account in that position \n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n\t\trequire(index < RAIRProductFacet.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n\t\treturn s._ownedTokens[owner][index];\n\t}\n\n\t/// @notice this funtions allow us to know the balance of an account\n\t/// @param owner Contains the address which balance we want to verify\n\t/// @return uint256 with the current balance of the account\n\tfunction balanceOf(address owner) public view returns (uint256) {\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn s._balances[owner];\n\t}\n\n\t/// @notice This function allow us to verify if a token exist or not \n\t/// @param tokenId Contains the token Id that we want to check\n\t/// @return bool to indicate if the token exist or not\n\tfunction _exists(uint256 tokenId) internal view returns (bool) {\n        return s._owners[tokenId] != address(0);\n    }\n\t\n\t/// @notice\tLoops through a range of tokens inside a collection and returns the first token without an owner\n\t/// @dev\tUses a loop, do not call this from a non-view function!\n\t/// @dev \tThis functions require that the collection exist to properly work \n\t/// @param\tcollectionId\tIndex of the collection that we want to loop\n\t/// @param\tstartingIndex\tIndex of the starting token of the product\n\t/// @param\tendingIndex\t\tIndex of the last token of the product \n\t/// @return nextIndex\t\tWith the next starting point available for new products\n\tfunction getNextSequentialIndex(uint collectionId, uint startingIndex, uint endingIndex) public view collectionExists(collectionId) returns(uint nextIndex) {\n\t\tproduct memory currentProduct = s.products[collectionId];\n\t\tfor (uint i = currentProduct.startingToken + startingIndex; i <= currentProduct.startingToken + endingIndex; i++) {\n\t\t\tif (!_exists(i)) {\n\t\t\t\treturn i - currentProduct.startingToken;\n\t\t\t}\n\t\t}\n\t\trequire(false, \"RAIR ERC721: There are no available tokens in this range.\");\n\t}\n\n\t/// @notice\tLoops over the user's tokens looking for one that belongs to a product and a specific range\n\t/// @dev\tLoops are expensive in solidity, so don't use this in a function that requires gas\n\t/// @param\tuserAddress\t\t\tAddress that will be uses to see the belonging tokens of a product and a range\n\t/// @param\tproductIndex\t\tIndex of the collection to search\n\t/// @param\tstartingToken\t\tStarting token to search\n\t/// @param\tendingToken\t\t\tLast token to search \n\t/// @return bool \t\t\t\tWhich respond if the tokens belongs or not to a product and a range\n\tfunction hasTokenInProduct(\n\t\t\t\taddress userAddress,\n\t\t\t\tuint productIndex,\n\t\t\t\tuint startingToken,\n\t\t\t\tuint endingToken) public view returns (bool) {\n\t\tproduct memory aux = s.products[productIndex];\n\t\tif (aux.endingToken != 0) {\n\t\t\tfor (uint i = 0; i < balanceOf(userAddress); i++) {\n\t\t\t\tuint token = tokenOfOwnerByIndex(userAddress, i);\n\t\t\t\tif (s.tokenToProduct[token] == productIndex &&\n\t\t\t\t\t\ttoken >= aux.startingToken + startingToken &&\n\t\t\t\t\t\ttoken <= aux.startingToken + endingToken) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/// @notice\tReturns the number of tokens inside a product\n\t/// @param\tproductIndex \tProduct index to verify\n\t/// @return length  \t \tNumber of tokens already minted\n\tfunction mintedTokensInProduct(uint productIndex) public view returns (uint length) {\n\t\tlength = s.tokensByProduct[productIndex].length;\n\t}\n\t\n\t/// @notice\tCreates a new product\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param\t_productName \tName of the product to create\n\t/// @param\t_copies\t\t\tAmount of tokens inside the product\n\tfunction createProduct(string memory _productName, uint _copies) public onlyRole(CREATOR) {\n\t\tuint lastToken = s.products.length == 0 ? 0 : s.products[s.products.length - 1].endingToken + 1;\n\t\t\n\t\tproduct storage newProduct = s.products.push();\n\n\t\tnewProduct.startingToken = lastToken;\n\t\tnewProduct.endingToken = newProduct.startingToken + _copies - 1;\n\t\tnewProduct.name = string(_productName);\n\t\tnewProduct.mintableTokens = _copies;\n\t\t\n\t\temit CreatedCollection(s.products.length - 1, _productName, lastToken, _copies);\n\t}\n}"
    },
    "contracts/tokens/RAIR Token Facets/RAIRMetadataFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport './AppStorage.sol';\n\n/// @title  RAIR Metadata facet contract\n/// @notice You can use this contract to administrate the metadata asociated to the Rair facet\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721\ncontract RAIRMetadataFacet is AccessControlAppStorageEnumerable721 {\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n\tusing Strings for uint256;\n\n\t/// @notice This event stores in the blockchain when the base code of all the tokens has an update in its URI\n    /// @param  newURI \t\t\t\tContains the new  base identifier for all the tokens\n\t/// @param  appendTokenIndex \tContains the index of the tokens appended to the URI\n\t/// @param \tmetadataExtension \tFile extension (if exists)\n\tevent UpdatedBaseURI(string newURI, bool appendTokenIndex, string metadataExtension);\n\t/// @notice This event stores in the blockchain when a token has a change in its URI\n\t/// @param  tokenId \t\t\tContains the index of the token appended to the URI\n    /// @param  newURI \t\t\t\tContains the new identifier for the token\n\tevent UpdatedTokenURI(uint tokenId, string newURI);\n\t/// @notice This event stores in the blockchain when a product has a change in its URI\n\t/// @param \tproductId \t\t\tContains the index of the product to change\n    /// @param  newURI \t\t\t\tContains the new identifier for the product\n\t/// @param  appendTokenIndex \tContains the index of the token appended to the URI\n\t/// @param \tmetadataExtension \tFile extension (if exists)\n\tevent UpdatedProductURI(uint productId, string newURI, bool appendTokenIndex, string metadataExtension);\n\t/// @notice This event stores in the blockchain when a range has a change in its URI\n\t/// @param \trangeId \t\t\tContains the index of the product to change\n    /// @param  newURI \t\t\t\tContains the new identifier for the product\n\t/// @param  appendTokenIndex \tContains the index of the token appended to the URI\n\t/// @param \tmetadataExtension \tFile extension (if exists)\n\tevent UpdatedRangeURI(uint rangeId, string newURI, bool appendTokenIndex, string metadataExtension);\n\t/// @notice This event stores in the blockchain when a contract has a change in its URI\n    /// @param  newURI \t\t\t\tContains the new identifier for the contract \n\tevent UpdatedContractURI(string newURI);\n\t/// @notice This event informs the new extension all metadata URIs will have appended at the end\n\t/// @dev \tIt will be appended ONLY if the token ID has to also be appended\n\t/// @param \tnewExtension The new extension for all the URIs\n    event UpdatedURIExtension(string newExtension);\n\n\n\t// For OpenSea's Freezing\n\tevent PermanentURI(string _value, uint256 indexed _id);\n\n\t/// @notice This function allows us to check if the token exist or not\n\t/// @param\ttokenId\tContains the index of the token that we want to verify \n\t/// @return bool Answer true if the token exist or false if not \n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn s._owners[tokenId] != address(0);\n\t}\n\n\t/// @notice\tReturns the token index inside the product\n\t/// @param\ttoken\tToken ID to find\n\t/// @return tokenIndex which contains the corresponding token index\n\tfunction tokenToCollectionIndex(uint token) public view returns (uint tokenIndex) {\n\t\treturn token - s.products[s.tokenToProduct[token]].startingToken;\n\t}\n\n\t/// @notice\tUpdates the unique URI of all the tokens, but in a single transaction\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tUses the single function so it also emits an event\n\t/// @dev \tThis function requires that all the tokens have a corresponding URI\n\t/// @param\ttokenIds\tToken Indexes that will be given an URI\n\t/// @param\tnewURIs\t\tNew URIs to be set\n\tfunction setUniqueURIBatch(uint[] calldata tokenIds, string[] calldata newURIs) external onlyRole(CREATOR) {\n\t\trequire(tokenIds.length == newURIs.length, \"RAIR ERC721: Token IDs and URIs should have the same length\");\n\t\tfor (uint i = 0; i < tokenIds.length; i++) {\n\t\t\tsetUniqueURI(tokenIds[i], newURIs[i]);\n\t\t}\n\t}\n\t\n\t/// @notice\tGives an individual token an unique URI\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tEmits an event so there's provenance\n\t/// @param\ttokenId\tToken Index that will be given an URI\n\t/// @param\tnewURI\tNew URI to be given\n\tfunction setUniqueURI(uint tokenId, string calldata newURI) public onlyRole(CREATOR) {\n\t\ts.uniqueTokenURI[tokenId] = newURI;\n\t\temit UpdatedTokenURI(tokenId, newURI);\n\t}\n\n\t/// @notice  Updates the metadata extension added at the end of all tokens\n    /// @dev     Must include the . before the extension\n    /// @param extension     Extension to be added at the end of all contract wide tokens\n    function setMetadataExtension(string calldata extension) external onlyRole(CREATOR) {\n        require(bytes(extension)[0] == '.', \"RAIR ERC721: Extension must start with a '.'\");\n        s._metadataExtension = extension;\n        emit UpdatedURIExtension(s._metadataExtension);\n    }\n\n\t/// @notice\tGives all tokens within a range a specific URI\n    /// @dev\tEmits an event so there's provenance\n    /// @param\trangeId\t\t\t\tToken Index that will be given an URI\n    /// @param\tnewURI\t\t    \tNew URI to be given\n    /// @param\tappendTokenIndex\tFlag to append the token index at the end of the new URI\n    function setRangeURI(\n        uint rangeId,\n        string calldata newURI,\n        bool appendTokenIndex\n    ) public onlyRole(CREATOR) {\n        s.rangeURI[rangeId] = newURI;\n        s.appendTokenIndexToRangeURI[rangeId] = appendTokenIndex;\n        emit UpdatedRangeURI(rangeId, newURI, appendTokenIndex, s._metadataExtension);\n    }\n\n\t/// @notice\tGives an individual token an unique URI\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tEmits an event so there's provenance\n\t/// @param\tproductId\t\t\t\t\t\tToken Index that will be given an URI\n\t/// @param\tnewURI\t\t\t\t\t\t\tNew URI to be given\n\t/// @param\tappendTokenIndexToProductURI \tIf true, it will append the token index to the URI\n\tfunction setCollectionURI(uint productId, string calldata newURI, bool appendTokenIndexToProductURI) public onlyRole(CREATOR) {\n\t\ts.productURI[productId] = newURI;\n\t\ts.appendTokenIndexToProductURI[productId] = appendTokenIndexToProductURI;\n\t\temit UpdatedProductURI(productId, newURI, appendTokenIndexToProductURI, s._metadataExtension);\n\t}\n\n\t/// @notice\tThis function use OpenSea's to freeze the metadata\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param tokenId Token Index that will be given an URI\n\tfunction freezeMetadata(uint tokenId) public onlyRole(CREATOR) {\n\t\temit PermanentURI(tokenURI(tokenId), tokenId);\n\t}\n\n\t/// @notice\tThis function allow us to set a new contract URI\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param newURI New URI to be given\n\tfunction setContractURI(string calldata newURI) external onlyRole(CREATOR) {\n\t\ts.contractMetadataURI = newURI;\n\t\temit UpdatedContractURI(newURI);\n\t}\n\n\t/// @notice\tThis function allow us to see the current URI of the contract\n\t/// @return string with the URI of the contract \n\tfunction contractURI() public view returns (string memory) {\n\t\treturn s.contractMetadataURI;\n\t}\n\t\n\t/// @notice\tSets the Base URI for ALL tokens\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev\tCan be overriden by the specific token URI\n\t/// @param\tnewURI\tURI to be used\n\t/// @param\tappendTokenIndexToBaseURI\tURI to be used\n\tfunction setBaseURI(string calldata newURI, bool appendTokenIndexToBaseURI) external onlyRole(CREATOR) {\n\t\ts.baseURI = newURI;\n\t\ts.appendTokenIndexToBaseURI = appendTokenIndexToBaseURI;\n\t\temit UpdatedBaseURI(newURI, appendTokenIndexToBaseURI, s._metadataExtension);\n\t}\n\n\t/// @notice\tReturns a token's URI\n    /// @dev\tWill return unique token URI or product URI or contract URI\n    /// @param\ttokenId\t\tToken Index to look for\n\t/// @return string with the URI of the toke that we are using\n    function tokenURI(uint tokenId)\n        public\n        view\n        returns (string memory)\n    {\n        // Unique token URI\n        string memory URI = s.uniqueTokenURI[tokenId];\n        if (bytes(URI).length > 0) {\n            return URI;\n        }\n\n        // Range wide URI\n        URI = s.rangeURI[s.tokenToRange[tokenId]];\n        if (bytes(URI).length > 0) {\n            if (s.appendTokenIndexToRangeURI[s.tokenToRange[tokenId]]) {\n                return\n                    string(\n                        abi.encodePacked(\n                            URI,\n                            tokenToCollectionIndex(tokenId).toString(),\n                            s._metadataExtension\n                        )\n                    );\n            }\n            return URI;\n        }\n\n        // Collection wide URI\n        URI = s.productURI[s.tokenToProduct[tokenId]];\n        if (bytes(URI).length > 0) {\n            if (s.appendTokenIndexToProductURI[s.tokenToProduct[tokenId]]) {\n                return\n                    string(\n                        abi.encodePacked(\n                            URI,\n                            tokenToCollectionIndex(tokenId).toString(),\n                            s._metadataExtension\n                        )\n                    );\n            }\n            return URI;\n        }\n\n        URI = s.baseURI;\n        if (s.appendTokenIndexToBaseURI) {\n            return\n                string(\n                    abi.encodePacked(\n                        URI,\n                        tokenId.toString(),\n                        s._metadataExtension\n                    )\n                );\n        }\n        return URI;\n    }\n}"
    },
    "contracts/tokens/RAIR Token Facets/RangesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.16;\n\nimport './AppStorage.sol';\n/// @title  This is contract to manage the Rair token ranges facet\n/// @notice You can use this contract to administrate ranges, transfers & minting of the tokens\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721\ncontract RAIRRangesFacet is AccessControlAppStorageEnumerable721 {\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n\n\t/// @notice This event stores in the blockchain when the NFT range is correctly created\n    /// @param  productIndex Contains the position where the product was indexed\n\t/// @param  start Contains the start position of the range of nft collection\n\t/// @param  end Contains the last NFT of the range collection\n\t/// @param  price Contains the selling price for the range of NFT\n\t/// @param  tokensAllowed Contains all the allowed NFT tokens in the range that are available for sell\n\t/// @param  lockedTokens Contains all the NFT tokens in the range that are unavailable for sell\n\t/// @param  name Contains the name for the created NFT collection range\n\t/// @param  rangeIndex Contains the position where the range was indexed\n\tevent CreatedRange(uint productIndex, uint start, uint end, uint price, uint tokensAllowed, uint lockedTokens, string name, uint rangeIndex);\n\t/// @notice This event stores in the blockchain when the NFT range is correctly updated\n    /// @param  rangeIndex Contains the position where the range was indexed\n\t/// @param  name Contains the name for the created NFT collection range\n\t/// @param  price Contains the selling price for the range of NFT\n\t/// @param  tokensAllowed Contains all the allowed NFT tokens in the range that are available for sell\n\t/// @param  lockedTokens Contains all the NFT tokens in the range that are unavailable for sell\n\tevent UpdatedRange(uint rangeIndex, string name, uint price, uint tokensAllowed, uint lockedTokens);\n\t/// @notice This event stores in the blockchain when the NFT range trading is effectively locked  \n    /// @param  rangeIndex Contains the position where the range was indexed\n\t/// @param  from Contains the starting NFT of the range that we want to lock\n\t/// @param  to Contains the last NFT of the range that we want to lock\n\t/// @param  lockedTokens Contains all the NFT tokens in the range that are unavailable for sell\n\tevent TradingLocked(uint indexed rangeIndex, uint from, uint to, uint lockedTokens);\n\t/// @notice This event stores in the blockchain when the NFT range trading is effectively unlocked \n    /// @param  rangeIndex Contains the position where the range was indexed\n\t/// @param  from Contains the starting NFT of the range that we want to lock\n\t/// @param  to Contains the last NFT of the range that we want to lock\n\tevent TradingUnlocked(uint indexed rangeIndex, uint from, uint to);\n\n\t// Auxiliary struct used to avoid Stack too deep errors\n\tstruct rangeData {\n\t\tuint rangeLength;\n\t\tuint price;\n\t\tuint tokensAllowed;\n\t\tuint lockedTokens;\n\t\tstring name;\n\t}\n\n\t/// @notice Verifies that the range exists\n\t/// @param\trangeID\tIdentification of the range to verify\n\tmodifier rangeExists(uint rangeID) {\n\t\trequire(s.ranges.length > rangeID, \"RAIR ERC721 Ranges: Range does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice This functions verify if the current colecction exist or not\n\t/// @param\tcollectionId\tIdentification of the collection that we want to use\n\tmodifier collectionExists(uint collectionId) {\n\t\trequire(s.products.length > collectionId, \"RAIR ERC721 Ranges: Collection does not exist\");\n\t\t_;\n\t}\n\n\t/// @notice This functions return us the product that containt the selected range\n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range \n\t/// @param\trangeIndex_\t\tIdentification of the range to verify\n\t/// @return uint which indicates the index of the product\n\tfunction rangeToProduct(uint rangeIndex_) public view rangeExists(rangeIndex_) returns (uint) {\n\t\treturn s.rangeToProduct[rangeIndex_];\n\t}\n\n\t/// @notice This functions allow us to check the information of the range\n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range \n\t/// @param\trangeId\tIdentification of the range to verify\n\t/// @return data \t\t\tInformation about the range\n\t/// @return productIndex \tContains the index of the product in the range\n\tfunction rangeInfo(uint rangeId) external view rangeExists(rangeId) returns(range memory data, uint productIndex) {\n\t\tdata = s.ranges[rangeId];\n\t\tproductIndex = s.rangeToProduct[rangeId];\n\t}\n\n\t/// @notice This functions shows is the range is currently locked or not \n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range \n\t/// @param\trangeId\tIdentification of the range to verify\n\t/// @return bool with the current status of the range lock\n\t///\t\t\ttrue for lock and false for unlocked\n\tfunction isRangeLocked(uint rangeId) external view rangeExists(rangeId) returns (bool) {\n\t\treturn s.ranges[rangeId].lockedTokens > 0;\n\t}\n\n\t/// @notice This functions shows the information for the range of a product\n\t/// @param\tcollectionId\tIndex of the product to verify\n\t/// @param\trangeIndex\t\tIndex of the range to verify\n\t/// @return data \t\t\tInformation about the range\n\tfunction productRangeInfo(uint collectionId, uint rangeIndex) external view collectionExists(collectionId) returns(range memory data) {\n\t\trequire(s.products[collectionId].rangeList.length > rangeIndex, \"RAIR ERC721 Ranges: Invalid range index\");\n\t\tdata = s.ranges[s.products[collectionId].rangeList[rangeIndex]];\n\t}\n\n\t/// @notice This functions allow us to update the information about a range\n\t/// @dev \tThis function requires that the rangeIndex_ points to an existing range\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @param\trangeId\t\t\tIdentification of the range to verify\n\t/// @param\tname\t\t\tContains the name for the created NFT collection range\n\t/// @param\tprice_\t\t\tContains the selling price for the range of NFT\n\t/// @param\ttokensAllowed_\tContains all the allowed NFT tokens in the range that are available for sell\n\t/// @param\tlockedTokens_\tContains all the NFT tokens in the range that are unavailable for sell\n\tfunction updateRange(uint rangeId, string memory name, uint price_, uint tokensAllowed_, uint lockedTokens_) public rangeExists(rangeId) onlyRole(CREATOR) {\n\t\trequire(price_ >= 100, \"RAIR ERC721: Minimum price allowed is 100 wei\");\n\t\trange storage selectedRange = s.ranges[rangeId];\n\t\trequire(selectedRange.rangeEnd - selectedRange.rangeStart + 1 >= tokensAllowed_, \"RAIR ERC721: Allowed tokens should be less than range's length\");\n\t\trequire(selectedRange.rangeEnd - selectedRange.rangeStart + 1 >= lockedTokens_, \"RAIR ERC721: Locked tokens should be less than range's length\");\n\t\tselectedRange.tokensAllowed = tokensAllowed_;\n\t\tif (lockedTokens_ > 0) {\n\t\t\temit TradingLocked(rangeId, selectedRange.rangeStart, selectedRange.rangeEnd, lockedTokens_);\n\t\t\tselectedRange.lockedTokens = lockedTokens_;\n\t\t}\n\t\tselectedRange.rangeName = name;\n\t\tselectedRange.rangePrice = price_;\n\t\temit UpdatedRange(rangeId, name, price_, tokensAllowed_, lockedTokens_);\n\t}\n\n\t/// @notice This functions allow us to know if a desidred range can be created or not\n\t/// @param\tproductId_\tContains the identification for the product\n\t/// @param\trangeStart_\tContains the tentative NFT to use as starting point of the range \n\t/// @param\trangeEnd_\tContains the tentative NFT to use as ending point of the range\n\t/// @return bool With the answer if the range cant be creater or not\n\tfunction canCreateRange(uint productId_, uint rangeStart_, uint rangeEnd_) public view returns (bool) {\n\t\tuint[] memory rangeList = s.products[productId_].rangeList;\n\t\tfor (uint i = 0; i < rangeList.length; i++) {\n\t\t\tif ((s.ranges[rangeList[i]].rangeStart <= rangeStart_ &&\n\t\t\t\t\ts.ranges[rangeList[i]].rangeEnd >= rangeStart_) || \n\t\t\t\t(s.ranges[rangeList[i]].rangeStart <= rangeEnd_ &&\n\t\t\t\t\ts.ranges[rangeList[i]].rangeEnd >= rangeEnd_)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t/// @notice This is a internal function that will create the NFT range if the requirements are meet\n\t/// @param\tproductId_\t\tContains the identification for the product\n\t/// @param\trangeLength_\tNumber of tokens contained in the range\n\t/// @param \tprice_ \t\t\tContains the selling price for the range of NFT\n\t/// @param \ttokensAllowed_ \tContains all the allowed NFT tokens in the range that are available for sell\n\t/// @param \tlockedTokens_ \tContains all the NFT tokens in the range that are unavailable for sell\n\t/// @param \tname_ \t\t\tContains the name for the created NFT collection range\n\tfunction _createRange(\n\t\tuint productId_,\n\t\tuint rangeLength_,\n\t\tuint price_,\n\t\tuint tokensAllowed_,\n\t\tuint lockedTokens_,\n\t\tstring memory name_\n\t) internal {\n\t\t// Sanity checks\n\t\t// 0 to make the offer free, over 100 to make sure paid offers can split the funds correctly\n\t\trequire(price_ == 0 || price_ >= 100, \"RAIR ERC721: Minimum price allowed is 100 wei\");\n\t\trequire(rangeLength_ >= tokensAllowed_, \"RAIR ERC721: Allowed tokens should be less than range's length\");\n\t\trequire(rangeLength_ >= lockedTokens_, \"RAIR ERC721: Locked tokens should be less than range's length\");\n\t\tproduct storage selectedProduct = s.products[productId_];\n\t\tuint lastTokenFromPreviousRange;\n\t\tif (selectedProduct.rangeList.length > 0) {\n\t\t\tlastTokenFromPreviousRange = s.ranges[selectedProduct.rangeList[selectedProduct.rangeList.length - 1]].rangeEnd + 1;\n\t\t}\n\n\t\trange storage newRange = s.ranges.push();\n\t\tuint rangeIndex = s.ranges.length - 1;\n\n\t\trequire(lastTokenFromPreviousRange + rangeLength_ - 1 <= selectedProduct.endingToken , \"RAIR ERC721: Range length exceeds collection limits!\");\n\n\t\tnewRange.rangeStart = lastTokenFromPreviousRange;\n\t\t// -1 because it includes the starting token\n\t\tnewRange.rangeEnd = lastTokenFromPreviousRange + rangeLength_ - 1;\n\t\tnewRange.tokensAllowed = tokensAllowed_;\n\t\tnewRange.mintableTokens = rangeLength_;\n\t\tnewRange.lockedTokens = lockedTokens_;\n\t\tif (lockedTokens_ > 0) {\n\t\t\temit TradingLocked(rangeIndex, newRange.rangeStart, newRange.rangeEnd, newRange.lockedTokens);\n\t\t} else if (lockedTokens_ == 0) {\n\t\t\temit TradingUnlocked(rangeIndex, newRange.rangeStart, newRange.rangeEnd);\n\t\t}\n\t\tnewRange.rangePrice = price_;\n\t\tnewRange.rangeName = name_;\n\t\ts.rangeToProduct[rangeIndex] = productId_;\n\t\tselectedProduct.rangeList.push(rangeIndex);\n\n\t\temit CreatedRange(\n\t\t\tproductId_,\n\t\t\tnewRange.rangeStart,\n\t\t\tnewRange.rangeEnd,\n\t\t\tnewRange.rangePrice,\n\t\t\tnewRange.tokensAllowed,\n\t\t\tnewRange.lockedTokens,\n\t\t\tnewRange.rangeName,\n\t\t\trangeIndex\n\t\t);\n\t}\n\n\t/// @notice This function that will create the NFT range if the requirements are meet\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev \tThis function require thar the collection ID match a valid collection \n\t/// @param\tcollectionId\tContains the identification for the product\n\t/// @param\trangeLength\t\tNumber of tokens contained in the range\n\t/// @param \tprice \t\t\tContains the selling price for the range of NFT\n\t/// @param \ttokensAllowed \tContains all the allowed NFT tokens in the range that are available for sell\n\t/// @param \tlockedTokens \tContains all the NFT tokens in the range that are unavailable for sell\n\t/// @param \tname \t\t\tContains the name for the created NFT collection range\n\tfunction createRange(\n\t\tuint collectionId,\n\t\tuint rangeLength,\n\t\tuint price,\n\t\tuint tokensAllowed,\n\t\tuint lockedTokens,\n\t\tstring calldata name\n\t) external onlyRole(CREATOR) collectionExists(collectionId) {\n\t\t_createRange(collectionId, rangeLength, price, tokensAllowed, lockedTokens, name);\n\t}\n\n\t/// @notice This function will create as many ranges as the data array requires\n\t/// @dev \tThis function is only available to an account with a `CREATOR` role\n\t/// @dev \tThis function require thar the collection ID match a valid collection \n\t/// @param\tcollectionId\tContains the identification for the product\n\t/// @param\tdata \t\t\tAn array with the data for all the ranges that we want to implement \n\tfunction createRangeBatch(\n\t\tuint collectionId,\n\t\trangeData[] calldata data\n\t) external onlyRole(CREATOR) collectionExists(collectionId) {\n\t\trequire(data.length > 0, \"RAIR ERC721: Empty array\");\n\t\tfor (uint i = 0; i < data.length; i++) {\n\t\t\t_createRange(collectionId, data[i].rangeLength, data[i].price, data[i].tokensAllowed, data[i].lockedTokens, data[i].name);\n\t\t}\n\t}\n}"
    },
    "contracts/tokens/RAIR-ERC721-Diamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.11; \n\n// Interfaces\n//import \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\n\nimport \"../diamondStandard/interfaces/IDiamondLoupe.sol\";\n\nimport './RAIR Token Facets/AppStorage.sol';\n\n/// @title  RAIR 721 Diamond\n/// @notice Diamond Contract implementing the bare minimum ERC-721 features\n/// @author Juan M. Sanchez M.\n/// @dev \tNotice that this contract is inheriting from AccessControlAppStorageEnumerable721 & ERC165\ncontract RAIR_ERC721_Diamond is AccessControlAppStorageEnumerable721, ERC165 {\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\n\tbytes32 public constant MINTER = keccak256(\"MINTER\");\n\tbytes32 public constant TRADER = keccak256(\"TRADER\");\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\t\n\t/// @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n\tconstructor(string memory name_, address creatorAddress_, uint16 creatorRoyalty_) {\n\t\ts._name = name_;\n\t\ts._symbol = \"RAIR\";\n\t\t\n\t\ts.factoryAddress = msg.sender;\n\t\ts.royaltyFee = creatorRoyalty_;\n\t\t_setRoleAdmin(MINTER, CREATOR);\n\t\t_setRoleAdmin(TRADER, CREATOR);\n\t\t_grantRole(CREATOR, creatorAddress_);\n\t\t_grantRole(MINTER, creatorAddress_);\n\t\t_grantRole(TRADER, creatorAddress_);\n\t}\n\n\t/// @notice This function allows us to know the factory address \n    /// @return address Contains the address of the factory contract\n\tfunction getFactoryAddress() public view returns (address) {\n\t\treturn s.factoryAddress;\n\t}\n\n\t/// @notice This function allows us to know the URI of the contract \n    /// @return address Contains the string with all the URI, this string is saved in memory \n\tfunction contractURI() public view returns (string memory) {\n\t\treturn s.contractMetadataURI;\n\t}\n\n\t/// @notice This function allows us to know if and interface is suported\n\t/// @param \tinterfaceId Contains the facet addresses and function selectors\n\t/// @return bool contains the value for the interface, it could be true or false\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n        \tinterfaceId == type(IERC721Enumerable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n\tfallback() external {\n\t\taddress facet = IDiamondLoupe(s.factoryAddress).facetAddress(msg.sig);\n\t\tassembly {\n\t\t\t// copy function selector and any arguments\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\t// execute function call using the facet\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n\t\t\t// get any return value\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\t// return any return value or error back to the caller\n\t\t\tswitch result\n\t\t\t\tcase 0 {\n\t\t\t\t\trevert(0, returndatasize())\n\t\t\t\t}\n\t\t\t\tdefault {\n\t\t\t\t\treturn(0, returndatasize())\n\t\t\t\t}\n\t\t}\n\t}\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {}
  }
}