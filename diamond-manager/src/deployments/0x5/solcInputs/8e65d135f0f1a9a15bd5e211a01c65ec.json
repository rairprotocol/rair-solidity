{
  "language": "Solidity",
  "sources": {
    "contracts/common/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nstruct RoleData {\r\n\tmapping(address => bool) members;\r\n\tbytes32 adminRole;\r\n}\r\n\r\nabstract contract AccessControlEnumerable is Context {\t\r\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role, _msgSender());\r\n        _;\r\n    }\r\n\r\n    function renounceRole(bytes32 role, address account) public {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function _checkRole(bytes32 role, address account) internal view {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(uint160(account), 20),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n\tfunction hasRole(bytes32 role, address account) public view virtual returns (bool);\r\n\r\n\tfunction getRoleAdmin(bytes32 role) public view virtual returns (bytes32);\r\n\r\n\tfunction getRoleMember(bytes32 role, uint256 index) public view virtual returns (address);\r\n\r\n\tfunction getRoleMemberCount(bytes32 role) public view virtual returns (uint256);\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual;\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal virtual;\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal virtual;\r\n}"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/tokens/RAIR Token Facets/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport '../../common/AccessControl.sol';\r\n\r\nstruct range {\r\n\tuint rangeStart;\r\n\tuint rangeEnd;\r\n\tuint tokensAllowed;\r\n\tuint mintableTokens;\r\n\tuint lockedTokens;\r\n\tuint rangePrice;\r\n\tstring rangeName;\r\n}\r\n\r\nstruct product {\r\n\tuint startingToken;\r\n\tuint endingToken;\r\n\tuint mintableTokens;\r\n\tstring name;\r\n\tuint[] rangeList;\r\n}\r\n\r\nstruct AppStorage721 {\r\n\t// ERC721\r\n\tstring _name;\r\n\tstring _symbol;\r\n\tmapping(uint256 => address) _owners;\r\n\tmapping(address => uint256) _balances;\r\n\tmapping(uint256 => address) _tokenApprovals;\r\n\tmapping(address => mapping(address => bool)) _operatorApprovals;\r\n\t// ERC721 Enumerable\r\n\tmapping(address => mapping(uint256 => uint256)) _ownedTokens;\r\n\tmapping(uint256 => uint256) _ownedTokensIndex;\r\n\tuint256[] _allTokens;\r\n\tmapping(uint256 => uint256) _allTokensIndex;\r\n\t// Access Control Enumerable\r\n\tmapping(bytes32 => RoleData) _roles;\r\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\r\n\t// App\r\n\tstring baseURI;\r\n\taddress factoryAddress;\r\n\tuint16 royaltyFee;\r\n\tproduct[] products;\r\n\trange[] ranges;\r\n\tmapping(uint => uint) tokenToProduct;\r\n\tmapping(uint => uint) tokenToRange;\r\n\tmapping(uint => string) uniqueTokenURI;\r\n\tmapping(uint => string) productURI;\r\n\tmapping(uint => bool) appendTokenIndexToProductURI;\r\n\tbool appendTokenIndexToBaseURI;\r\n\tmapping(uint => uint[]) tokensByProduct;\r\n\tstring contractMetadataURI;\r\n\tmapping(uint => uint) rangeToProduct;\r\n\tmapping(uint => bool) _minted;\r\n\t// Always add new variables at the end of the struct\r\n}\r\n\r\nlibrary LibAppStorage721 {\r\n\tfunction diamondStorage() internal pure\treturns (AppStorage721 storage ds) {\r\n\t\tassembly {\r\n\t\t\tds.slot := 0\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract AccessControlAppStorageEnumerable721 is Context {\r\n\tAppStorage721 internal s;\r\n\r\n\tusing EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\tevent RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n\tmodifier onlyRole(bytes32 role) {\r\n\t\t_checkRole(role, _msgSender());\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction renounceRole(bytes32 role, address account) public {\r\n\t\trequire(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\t\t_revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\r\n\t\t_grantRole(role, account);\r\n\t}\r\n\r\n\tfunction revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\r\n\t\t_revokeRole(role, account);\r\n\t}\r\n\r\n\tfunction _checkRole(bytes32 role, address account) internal view {\r\n\t\tif (!hasRole(role, account)) {\r\n\t\t\trevert(\r\n\t\t\t\tstring(\r\n\t\t\t\t\tabi.encodePacked(\r\n\t\t\t\t\t\t\"AccessControl: account \",\r\n\t\t\t\t\t\tStrings.toHexString(uint160(account), 20),\r\n\t\t\t\t\t\t\" is missing role \",\r\n\t\t\t\t\t\tStrings.toHexString(uint256(role), 32)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\r\n\t\treturn s._roles[role].members[account];\r\n\t}\r\n\r\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\r\n\t\treturn s._roles[role].adminRole;\r\n\t}\r\n\r\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\r\n\t\treturn s._roleMembers[role].at(index);\r\n\t}\r\n\r\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\r\n\t\treturn s._roleMembers[role].length();\r\n\t}\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\r\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\r\n\t\ts._roles[role].adminRole = adminRole;\r\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n\t}\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal {\r\n\t\tif (!hasRole(role, account)) {\r\n\t\t\ts._roles[role].members[account] = true;\r\n\t\t\temit RoleGranted(role, account, _msgSender());\r\n\t\t\ts._roleMembers[role].add(account);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal {\r\n\t\tif (hasRole(role, account)) {\r\n\t\t\ts._roles[role].members[account] = false;\r\n\t\t\temit RoleRevoked(role, account, _msgSender());\r\n\t\t\ts._roleMembers[role].remove(account);\r\n\t\t}\r\n\t}\r\n}"
    },
    "contracts/tokens/RAIR Token Facets/RangesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11;\r\n\r\nimport './AppStorage.sol';\r\n\r\ncontract RAIRRangesFacet is AccessControlAppStorageEnumerable721 {\r\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\r\n\r\n\tevent CreatedRange(uint productIndex, uint start, uint end, uint price, uint tokensAllowed, uint lockedTokens, string name, uint rangeIndex);\r\n\tevent UpdatedRange(uint rangeIndex, uint price, uint tokensAllowed, uint lockedTokens);\r\n\t\r\n\tevent TradingLocked(uint indexed rangeIndex, uint from, uint to, uint lockedTokens);\r\n\tevent TradingUnlocked(uint indexed rangeIndex, uint from, uint to);\r\n\r\n\t// Auxiliary struct used to avoid Stack too deep errors\r\n\tstruct rangeData {\r\n\t\tuint rangeStart;\r\n\t\tuint rangeEnd;\r\n\t\tuint price;\r\n\t\tuint tokensAllowed;\r\n\t\tuint lockedTokens;\r\n\t\tstring name;\r\n\t}\r\n\r\n\tfunction rangeInfo(uint rangeId) external view returns(range memory data) {\r\n\t\trequire(s.ranges.length > rangeId, \"RAIR ERC721 Ranges: Range does not exist\");\r\n\t\tdata = s.ranges[rangeId];\r\n\t}\r\n\r\n\tfunction isRangeLocked(uint rangeId) external view returns (bool) {\r\n\t\trequire(s.ranges.length > rangeId, \"RAIR ERC721 Ranges: Range does not exist\");\r\n\t\treturn s.ranges[rangeId].lockedTokens > 0;\r\n\t}\r\n\r\n\tfunction productRangeInfo(uint productId, uint rangeIndex) external view returns(range memory data) {\r\n\t\trequire(s.products.length > productId, \"RAIR ERC721 Ranges: Product does not exist\");\r\n\t\trequire(s.products[productId].rangeList.length > rangeIndex, \"RAIR ERC721 Ranges: Invalid range index\");\r\n\t\tdata = s.ranges[s.products[productId].rangeList[rangeIndex]];\r\n\t}\r\n\r\n\tfunction updateRange(uint rangeId, uint price_, uint tokensAllowed_, uint lockedTokens_) public onlyRole(CREATOR) {\r\n\t\trequire(s.ranges.length > rangeId, \"RAIR ERC721 Ranges: Range does not exist\");\r\n\t\trange storage selectedRange = s.ranges[rangeId];\r\n\t\trequire(selectedRange.rangeEnd - selectedRange.rangeStart + 1 >= tokensAllowed_, \"RAIR ERC721: Allowed tokens should be less than range's length\");\r\n\t\trequire(selectedRange.rangeEnd - selectedRange.rangeStart + 1 >= lockedTokens_, \"RAIR ERC721: Locked tokens should be less than range's length\");\r\n\t\tselectedRange.tokensAllowed = tokensAllowed_;\r\n\t\tif (lockedTokens_ > 0) {\r\n\t\t\temit TradingLocked(rangeId, selectedRange.rangeStart, selectedRange.rangeEnd, lockedTokens_);\r\n\t\t\tselectedRange.lockedTokens = lockedTokens_;\r\n\t\t}\r\n\t\tselectedRange.rangePrice = price_;\r\n\t\temit UpdatedRange(rangeId, price_, tokensAllowed_, lockedTokens_);\r\n\t}\r\n\r\n\tfunction canCreateRange(uint productId_, uint rangeStart_, uint rangeEnd_) public view returns (bool) {\r\n\t\tuint[] memory rangeList = s.products[productId_].rangeList;\r\n\t\tfor (uint i = 0; i < rangeList.length; i++) {\r\n\t\t\tif ((s.ranges[rangeList[i]].rangeStart <= rangeStart_ &&\r\n\t\t\t\t\ts.ranges[rangeList[i]].rangeEnd >= rangeStart_) || \r\n\t\t\t\t(s.ranges[rangeList[i]].rangeStart <= rangeEnd_ &&\r\n\t\t\t\t\ts.ranges[rangeList[i]].rangeEnd >= rangeEnd_)) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\tfunction _createRange(uint productId_, uint rangeStart_, uint rangeEnd_, uint price_, uint tokensAllowed_, uint lockedTokens_, string memory name_) internal {\r\n\t\tproduct storage selectedProduct = s.products[productId_];\r\n\t\trange storage newRange = s.ranges.push();\r\n\t\tuint rangeIndex = s.ranges.length - 1;\r\n\t\trequire(rangeStart_ <= rangeEnd_, 'RAIR ERC721: Invalid starting or ending token');\r\n\t\t// Add one because the starting token is included!\r\n\t\trequire(rangeEnd_ - rangeStart_ + 1 >= tokensAllowed_, \"RAIR ERC721: Allowed tokens should be less than range's length\");\r\n\t\trequire(rangeEnd_ - rangeStart_ + 1 >= lockedTokens_, \"RAIR ERC721: Locked tokens should be less than range's length\");\r\n\t\trequire(canCreateRange(productId_, rangeStart_, rangeEnd_), \"RAIR ERC721: Can't create a lock of this range\");\r\n\t\tnewRange.rangeStart = rangeStart_;\r\n\t\tnewRange.rangeEnd = rangeEnd_;\r\n\t\tnewRange.tokensAllowed = tokensAllowed_;\r\n\t\tnewRange.mintableTokens = rangeEnd_ - rangeStart_ + 1;\r\n\t\tnewRange.lockedTokens = lockedTokens_;\r\n\t\tif (lockedTokens_ > 0) {\r\n\t\t\temit TradingLocked(rangeIndex, rangeStart_, rangeEnd_, lockedTokens_);\r\n\t\t} else if (lockedTokens_ == 0) {\r\n\t\t\temit TradingUnlocked(rangeIndex, rangeStart_, rangeEnd_);\r\n\t\t}\r\n\t\tnewRange.rangePrice = price_;\r\n\t\tnewRange.rangeName = name_;\r\n\t\ts.rangeToProduct[rangeIndex] = productId_;\r\n\t\tselectedProduct.rangeList.push(rangeIndex);\r\n\t\temit CreatedRange(productId_, rangeStart_, rangeEnd_, price_, tokensAllowed_, lockedTokens_, name_, rangeIndex);\r\n\t}\r\n\r\n\tfunction createRange(uint productId, uint rangeStart, uint rangeEnd, uint price, uint tokensAllowed, uint lockedTokens, string calldata name) external onlyRole(CREATOR) {\r\n\t\trequire(s.products.length > productId, \"RAIR ERC721: Product does not exist\");\r\n\t\t_createRange(productId, rangeStart, rangeEnd, price, tokensAllowed, lockedTokens, name);\r\n\t}\r\n\r\n\tfunction createRangeBatch(\r\n\t\tuint productId,\r\n\t\trangeData[] calldata data\r\n\t) external onlyRole(CREATOR) {\r\n\t\trequire(data.length > 0, \"RAIR ERC721: Empty array\");\r\n\t\trequire(s.products.length > productId, \"RAIR ERC721: Product does not exist\");\r\n\t\tfor (uint i = 0; i < data.length; i++) {\r\n\t\t\t_createRange(productId, data[i].rangeStart, data[i].rangeEnd, data[i].price, data[i].tokensAllowed, data[i].lockedTokens, data[i].name);\r\n\t\t}\r\n\t}\r\n}"
    },
    "contracts/tokens/RAIR Token Facets/RAIRMetadataFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11;\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport './AppStorage.sol';\r\n\r\ncontract RAIRMetadataFacet is AccessControlAppStorageEnumerable721 {\r\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\r\n\tusing Strings for uint256;\r\n\r\n\tevent BaseURIChanged(string newURI, bool appendTokenIndex);\r\n\tevent TokenURIChanged(uint tokenId, string newURI);\r\n\tevent ProductURIChanged(uint productId, string newURI, bool appendTokenIndex);\r\n\tevent ContractURIChanged(string newURI);\r\n\r\n\t// For OpenSea's Freezing\r\n\tevent PermanentURI(string _value, uint256 indexed _id);\r\n\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return s._owners[tokenId] != address(0);\r\n    }\r\n\r\n\t/// @notice\tReturns the token index inside the product\r\n\t/// @param\ttoken\tToken ID to find\r\n\tfunction tokenToProductIndex(uint token) public view returns (uint tokenIndex) {\r\n\t\treturn token - s.products[s.tokenToProduct[token]].startingToken;\r\n\t}\r\n\r\n\t/// @notice\tUpdates the unique URI of a token, but in a single transaction\r\n\t/// @dev\tUses the single function so it also emits an event\r\n\t/// @param\ttokenIds\tToken Indexes that will be given an URI\r\n\t/// @param\tnewURIs\t\tNew URIs to be set\r\n\tfunction setUniqueURIBatch(uint[] calldata tokenIds, string[] calldata newURIs) external onlyRole(CREATOR) {\r\n\t\trequire(tokenIds.length == newURIs.length, \"RAIR ERC721: Token IDs and URIs should have the same length\");\r\n\t\tfor (uint i = 0; i < tokenIds.length; i++) {\r\n\t\t\tsetUniqueURI(tokenIds[i], newURIs[i]);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/// @notice\tGives an individual token an unique URI\r\n\t/// @dev\tEmits an event so there's provenance\r\n\t/// @param\ttokenId\tToken Index that will be given an URI\r\n\t/// @param\tnewURI\tNew URI to be given\r\n\tfunction setUniqueURI(uint tokenId, string calldata newURI) public onlyRole(CREATOR) {\r\n\t\ts.uniqueTokenURI[tokenId] = newURI;\r\n\t\temit TokenURIChanged(tokenId, newURI);\r\n\t}\r\n\r\n\t/// @notice\tGives an individual token an unique URI\r\n\t/// @dev\tEmits an event so there's provenance\r\n\t/// @param\tproductId\tToken Index that will be given an URI\r\n\t/// @param\tnewURI\t\tNew URI to be given\r\n\tfunction setProductURI(uint productId, string calldata newURI, bool appendTokenIndexToProductURI) public onlyRole(CREATOR) {\r\n\t\ts.productURI[productId] = newURI;\r\n\t\ts.appendTokenIndexToProductURI[productId] = appendTokenIndexToProductURI;\r\n\t\temit ProductURIChanged(productId, newURI, appendTokenIndexToProductURI);\r\n\t}\r\n\r\n\tfunction freezeMetadata(uint tokenId) public onlyRole(CREATOR) {\r\n\t\temit PermanentURI(tokenURI(tokenId), tokenId);\r\n\t}\r\n\r\n\tfunction setContractURI(string calldata newURI) external onlyRole(CREATOR) {\r\n\t\ts.contractMetadataURI = newURI;\r\n\t\temit ContractURIChanged(newURI);\r\n\t}\r\n\r\n\tfunction contractURI() public view returns (string memory) {\r\n\t\treturn s.contractMetadataURI;\r\n    }\r\n\t\r\n\t/// @notice\tSets the Base URI for ALL tokens\r\n\t/// @dev\tCan be overriden by the specific token URI\r\n\t/// @param\tnewURI\tURI to be used\r\n\tfunction setBaseURI(string calldata newURI, bool appendTokenIndexToBaseURI) external onlyRole(CREATOR) {\r\n\t\ts.baseURI = newURI;\r\n\t\ts.appendTokenIndexToBaseURI = appendTokenIndexToBaseURI;\r\n\t\temit BaseURIChanged(newURI, appendTokenIndexToBaseURI);\r\n\t}\r\n\r\n\t/// @notice\tReturns a token's URI, could be specific or general\r\n\t/// @dev\tIF the specific token URI doesn't exist, the general base URI will be returned\r\n\t/// @param\ttokenId\t\tToken Index to look for\r\n\tfunction tokenURI(uint tokenId) public view returns (string memory) {\r\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\t\tstring memory URI = s.uniqueTokenURI[tokenId];\r\n\t\tif (bytes(URI).length > 0) {\r\n\t\t\treturn URI;\r\n\t\t}\r\n\t\tURI = s.productURI[s.tokenToProduct[tokenId]];\r\n\t\tif (bytes(URI).length > 0) {\r\n\t\t\tif (s.appendTokenIndexToProductURI[s.tokenToProduct[tokenId]]) {\r\n\t\t\t\treturn string(abi.encodePacked(URI, tokenToProductIndex(tokenId).toString()));\r\n\t\t\t}\r\n\t\t\treturn URI; \r\n\t\t}\r\n\t\tURI = s.baseURI;\r\n\t\tif (bytes(URI).length > 0) {\r\n\t        if (s.appendTokenIndexToBaseURI) {\r\n\t\t\t\treturn string(abi.encodePacked(URI, tokenId.toString()));\r\n\t\t\t}\r\n\t\t\treturn URI;\r\n\t\t}\r\n        return \"\";\r\n\t}\r\n}"
    },
    "contracts/Marketplace/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\n\r\nstruct feeSplits {\r\n\taddress recipient;\r\n\tuint percentage;\r\n}\r\n\r\nstruct mintingOffer {\r\n\taddress erc721Address;\r\n\taddress nodeAddress;\r\n\tuint rangeIndex;\r\n\tfeeSplits[] fees;\r\n\tbool visible;\r\n}\r\n\r\nstruct RoleData {\r\n\tmapping(address => bool) members;\r\n\tbytes32 adminRole;\r\n}\r\n\r\nstruct AppStorage {\r\n\t// Access Control Enumerable\r\n\tmapping(bytes32 => RoleData) _roles;\r\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\r\n\t// App\r\n\tuint16 decimals;\r\n\tuint decimalPow;\r\n\tuint nodeFee;\r\n\tuint treasuryFee;\r\n\taddress treasuryAddress;\r\n\tmintingOffer[] mintingOffers;\r\n\tmapping(address => mapping(uint => uint)) addressToRangeOffer;\r\n\tmapping(address => uint[]) addressToOffers;\r\n\t// Always add new fields at the end of the struct, that way the structure can be upgraded\r\n}\r\n\r\nlibrary LibAppStorage {\r\n\tfunction diamondStorage() internal pure\treturns (AppStorage storage ds) {\r\n\t\tassembly {\r\n\t\t\tds.slot := 0\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract AccessControlAppStorageEnumerableMarket is Context {\r\n\tusing EnumerableSet for EnumerableSet.AddressSet;\r\n\t\r\n\tAppStorage internal s;\r\n\r\n\tevent RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\tevent RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role, _msgSender());\r\n        _;\r\n    }\r\n\r\n    function renounceRole(bytes32 role, address account) public {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function grantRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    function revokeRole(bytes32 role, address account) public onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    function _checkRole(bytes32 role, address account) internal view {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(uint160(account), 20),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n\tfunction hasRole(bytes32 role, address account) public view returns (bool) {\r\n\t\treturn s._roles[role].members[account];\r\n\t}\r\n\r\n\tfunction getRoleAdmin(bytes32 role) public view returns (bytes32) {\r\n\t\treturn s._roles[role].adminRole;\r\n\t}\r\n\r\n\tfunction getRoleMember(bytes32 role, uint256 index) public view returns (address) {\r\n\t\treturn s._roleMembers[role].at(index);\r\n\t}\r\n\r\n\tfunction getRoleMemberCount(bytes32 role) public view returns (uint256) {\r\n\t\treturn s._roleMembers[role].length();\r\n\t}\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal {\r\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\r\n\t\ts._roles[role].adminRole = adminRole;\r\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n\t}\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal {\r\n\t\tif (!hasRole(role, account)) {\r\n\t\t\ts._roles[role].members[account] = true;\r\n\t\t\temit RoleGranted(role, account, _msgSender());\r\n\t\t\ts._roleMembers[role].add(account);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal {\r\n\t\tif (hasRole(role, account)) {\r\n\t\t\ts._roles[role].members[account] = false;\r\n\t\t\temit RoleRevoked(role, account, _msgSender());\r\n\t\t\ts._roleMembers[role].remove(account);\r\n\t\t}\r\n\t}\r\n}"
    },
    "contracts/Marketplace/MarketplaceDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\n// Parent classes\r\nimport './AppStorage.sol';\r\nimport '../diamondStandard/Diamond.sol';\r\n\r\n/// @title  RAIR ERC721 Marketplace Diamond\r\n/// @notice Handles the trading of ERC721 RAIR Tokens\r\n/// @author Juan M. Sanchez M.\r\ncontract MarketplaceDiamond is Diamond, AccessControlAppStorageEnumerableMarket {\r\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\r\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\r\n\t\ts.decimals = 3;\r\n\t\ts.decimalPow = 10**3;\r\n\t\ts.nodeFee = 1 * s.decimalPow;\r\n\t\ts.treasuryFee = 9 * s.decimalPow;\r\n\t\t_setRoleAdmin(MAINTAINER, MAINTAINER);\r\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n\t\t_grantRole(MAINTAINER, msg.sender);\r\n\t}\r\n}"
    },
    "contracts/diamondStandard/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\r\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\r\n\r\ncontract Diamond {    \r\n\r\n    constructor(address _contractOwner, address _diamondCutFacet) payable {        \r\n        LibDiamond.setContractOwner(_contractOwner);\r\n\r\n        // Add the diamondCut external function from the diamondCutFacet\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\r\n        bytes4[] memory functionSelectors = new bytes4[](1);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondCutFacet, \r\n            action: IDiamondCut.FacetCutAction.Add, \r\n            functionSelectors: functionSelectors\r\n        });\r\n        LibDiamond.diamondCut(cut, address(0), \"\");        \r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        LibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\r\n        // get diamond storage\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        // get facet from function selector\r\n        address facet = address(bytes20(ds.facets[msg.sig]));\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        // Execute external function from facet using delegatecall and return any value.\r\n        assembly {\r\n            // copy function selector and any arguments\r\n            calldatacopy(0, 0, calldatasize())\r\n            // execute function call using the facet\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            // get any return value\r\n            returndatacopy(0, 0, returndatasize())\r\n            // return any return value or error back to the caller\r\n            switch result\r\n                case 0 {\r\n                    revert(0, returndatasize())\r\n                }\r\n                default {\r\n                    return(0, returndatasize())\r\n                }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/diamondStandard/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        // maps function selectors to the facets that execute the functions.\r\n        // and maps the selectors to their position in the selectorSlots array.\r\n        // func selector => address facet, selector position\r\n        mapping(bytes4 => bytes32) facets;\r\n        // array of slots of function selectors.\r\n        // each slot holds 8 function selectors.\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        // The number of function selectors in selectorSlots\r\n        uint16 selectorCount;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                // add facet for selector\r\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\r\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n                    // only useful if immutable functions exist\r\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n                    // replace selector with last selector in ds.facets\r\n                    // gets the last selector\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n"
    },
    "contracts/diamondStandard/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
    },
    "contracts/Factory/FactoryDiamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\n// Interfaces\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\r\n\r\n// Parent classes\r\n\r\nimport './AppStorage.sol';\r\nimport '../diamondStandard/Diamond.sol';\r\n\r\n/// @title  RAIR ERC721 Factory\r\n/// @notice Handles the deployment of ERC721 RAIR Tokens\r\n/// @author Juan M. Sanchez M.\r\n/// @dev \tUses AccessControl for the reception of ERC777 tokens!\r\ncontract FactoryDiamond is Diamond, AccessControlAppStorageEnumerable {\r\n\tIERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\r\n\t\r\n\tbytes32 public constant OWNER = keccak256(\"OWNER\");\r\n\tbytes32 public constant ERC777 = keccak256(\"ERC777\");\r\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n\tconstructor(address _diamondCut) Diamond(msg.sender, _diamondCut) {\r\n\t\t_ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777TokensRecipient\"), address(this));\r\n\t\ts.failsafe = 'This is a test!';\r\n\t\t_setRoleAdmin(OWNER, OWNER);\r\n\t\t_setRoleAdmin(ERC777, OWNER);\r\n\t\t_grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n\t\t_grantRole(OWNER, msg.sender);\r\n\t}\r\n}"
    },
    "@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC1820Registry.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the global ERC1820 Registry, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n * implementers for interfaces in this registry, as well as query support.\n *\n * Implementers may be shared by multiple accounts, and can also implement more\n * than a single interface for each account. Contracts can implement interfaces\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\n * contract.\n *\n * {IERC165} interfaces can also be queried via the registry.\n *\n * For an in-depth explanation and source code analysis, see the EIP text.\n */\ninterface IERC1820Registry {\n    /**\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\n     * account is able to set interface implementers for it.\n     *\n     * By default, each account is its own manager. Passing a value of `0x0` in\n     * `newManager` will reset the manager to this initial state.\n     *\n     * Emits a {ManagerChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     */\n    function setManager(address account, address newManager) external;\n\n    /**\n     * @dev Returns the manager for `account`.\n     *\n     * See {setManager}.\n     */\n    function getManager(address account) external view returns (address);\n\n    /**\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\n     * `interfaceHash`.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     * The zero address can also be used in `implementer` to remove an old one.\n     *\n     * See {interfaceHash} to learn how these are created.\n     *\n     * Emits an {InterfaceImplementerSet} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the current manager for `account`.\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n     * end in 28 zeroes).\n     * - `implementer` must implement {IERC1820Implementer} and return true when\n     * queried for support, unless `implementer` is the caller. See\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n     */\n    function setInterfaceImplementer(\n        address account,\n        bytes32 _interfaceHash,\n        address implementer\n    ) external;\n\n    /**\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n     * implementer is registered, returns the zero address.\n     *\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n     * zeroes), `account` will be queried for support of it.\n     *\n     * `account` being the zero address is an alias for the caller's address.\n     */\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n\n    /**\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n     * corresponding\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n     */\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n\n    /**\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n     * @param account Address of the contract for which to update the cache.\n     * @param interfaceId ERC165 interface for which to update the cache.\n     */\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not.\n     * If the result is not cached a direct lookup on the contract address is performed.\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n     * {updateERC165Cache} with the contract address.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n\n    /**\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n     * @param account Address of the contract to check.\n     * @param interfaceId ERC165 interface to check.\n     * @return True if `account` implements `interfaceId`, false otherwise.\n     */\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n\n    event ManagerChanged(address indexed account, address indexed newManager);\n}\n"
    },
    "contracts/Factory/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\r\nimport \"../common/AccessControl.sol\";\r\n\r\nstruct AppStorage {\r\n\t// Access Control Enumerable\r\n\tmapping(bytes32 => RoleData) _roles;\r\n\tstring failsafe;\r\n\tmapping(bytes32 => EnumerableSet.AddressSet) _roleMembers;\r\n\t// App\r\n\taddress[] creators;\r\n\tmapping(address => address[]) creatorToContracts;\r\n\tmapping(address => address) contractToCreator;\r\n\tmapping(address => uint) deploymentCostForToken;\r\n\t// Always add new variables at the end of the struct!\r\n}\r\n\r\nlibrary LibAppStorage {\r\n\tfunction diamondStorage() internal pure\treturns (AppStorage storage ds) {\r\n\t\tassembly {\r\n\t\t\tds.slot := 0\r\n\t\t}\r\n\t}\r\n}\r\n\r\ncontract AccessControlAppStorageEnumerable is Context, AccessControlEnumerable {\r\n\tusing EnumerableSet for EnumerableSet.AddressSet;\r\n\t\r\n\tAppStorage internal s;\r\n\r\n\tfunction hasRole(bytes32 role, address account) public view override returns (bool) {\r\n\t\treturn s._roles[role].members[account];\r\n\t}\r\n\r\n\tfunction getRoleAdmin(bytes32 role) public view override returns (bytes32) {\r\n\t\treturn s._roles[role].adminRole;\r\n\t}\r\n\r\n\tfunction getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\r\n\t\treturn s._roleMembers[role].at(index);\r\n\t}\r\n\r\n\tfunction getRoleMemberCount(bytes32 role) public view override returns (uint256) {\r\n\t\treturn s._roleMembers[role].length();\r\n\t}\r\n\r\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal override {\r\n\t\tbytes32 previousAdminRole = getRoleAdmin(role);\r\n\t\ts._roles[role].adminRole = adminRole;\r\n\t\temit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n\t}\r\n\r\n\tfunction _grantRole(bytes32 role, address account) internal override {\r\n\t\tif (!hasRole(role, account)) {\r\n\t\t\ts._roles[role].members[account] = true;\r\n\t\t\temit RoleGranted(role, account, _msgSender());\r\n\t\t\ts._roleMembers[role].add(account);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _revokeRole(bytes32 role, address account) internal override {\r\n\t\tif (hasRole(role, account)) {\r\n\t\t\ts._roles[role].members[account] = false;\r\n\t\t\temit RoleRevoked(role, account, _msgSender());\r\n\t\t\ts._roleMembers[role].remove(account);\r\n\t\t}\r\n\t}\r\n}"
    },
    "contracts/Factory/facets/TokensFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport '../AppStorage.sol';\r\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\r\n\r\ncontract TokensFacet is AccessControlAppStorageEnumerable {\r\n\tbytes32 constant OWNER = keccak256(\"OWNER\");\r\n\tbytes32 constant ERC777 = keccak256(\"ERC777\");\r\n\t\r\n\tevent NewTokenAccepted(address contractAddress, uint priceToDeploy, address responsible);\r\n\tevent TokenNoLongerAccepted(address erc777, address responsible);\r\n\tevent TokensWithdrawn(address recipient, address erc777, uint amount);\r\n\r\n\t/// @notice Transfers tokens from the factory to any of the OWNER addresses\r\n\t/// @dev \tIf the contract has less than the amount, the ERC777 contract will revert\r\n\t/// @dev \tAccessControl makes sure only an OWNER can withdraw\r\n\t/// @param \terc777\tAddress of the ERC777 contract\r\n\t/// @param \tamount\tAmount of tokens to withdraw\r\n\tfunction withdrawTokens(address erc777, uint amount) public onlyRole(OWNER) {\r\n\t\trequire(hasRole(ERC777, erc777), \"RAIR Factory: Specified contract isn't an approved erc777 contract\");\r\n\t\tIERC777(erc777).send(msg.sender, amount, bytes(\"Factory Withdraw\"));\r\n\t\temit TokensWithdrawn(msg.sender, erc777, amount);\r\n\t}\r\n\r\n\t/// @notice\tAdds an address to the list of allowed minters\r\n\t/// @param\t_erc777Address\tAddress of the new Token\r\n\tfunction acceptNewToken(address _erc777Address, uint _priceToDeploy) public onlyRole(OWNER) {\r\n\t\tgrantRole(ERC777, _erc777Address);\r\n\t\ts.deploymentCostForToken[_erc777Address] = _priceToDeploy;\r\n\t\temit NewTokenAccepted(_erc777Address, _priceToDeploy, msg.sender);\r\n\t}\r\n\r\n\t/// @notice\tRemoves an address from the list of allowed minters\r\n\t/// @param\t_erc777Address\tAddress of the Token\r\n\tfunction removeToken(address _erc777Address) public onlyRole(OWNER) {\r\n\t\trevokeRole(ERC777, _erc777Address);\r\n\t\ts.deploymentCostForToken[_erc777Address] = 0;\r\n\t\temit TokenNoLongerAccepted(_erc777Address, msg.sender);\r\n\t}\r\n\r\n\t/// @notice\tReturns the number of required tokens, given an erc777 address\r\n\tfunction getDeploymentCost(address erc777) public view returns (uint price) {\r\n\t\tprice = s.deploymentCostForToken[erc777];\r\n\t}\r\n}"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777Token standard as defined in the EIP.\n *\n * This contract uses the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n * token holders and recipients react to token movements by using setting implementers\n * for the associated interfaces in said registry. See {IERC1820Registry} and\n * {ERC1820Implementer}.\n */\ninterface IERC777 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the smallest part of the token that is not divisible. This\n     * means all token operations (creation, movement and destruction) must have\n     * amounts that are a multiple of this number.\n     *\n     * For most token contracts, this value will equal 1.\n     */\n    function granularity() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`owner`).\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * If send or receive hooks are registered for the caller and `recipient`,\n     * the corresponding functions will be called with `data` and empty\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\n     * total supply.\n     *\n     * If a send hook is registered for the caller, the corresponding function\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - the caller must have at least `amount` tokens.\n     */\n    function burn(uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev Returns true if an account is an operator of `tokenHolder`.\n     * Operators can send and burn tokens on behalf of their owners. All\n     * accounts are their own operator.\n     *\n     * See {operatorSend} and {operatorBurn}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n\n    /**\n     * @dev Make an account an operator of the caller.\n     *\n     * See {isOperatorFor}.\n     *\n     * Emits an {AuthorizedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function authorizeOperator(address operator) external;\n\n    /**\n     * @dev Revoke an account's operator status for the caller.\n     *\n     * See {isOperatorFor} and {defaultOperators}.\n     *\n     * Emits a {RevokedOperator} event.\n     *\n     * Requirements\n     *\n     * - `operator` cannot be calling address.\n     */\n    function revokeOperator(address operator) external;\n\n    /**\n     * @dev Returns the list of default operators. These accounts are operators\n     * for all token holders, even if {authorizeOperator} was never called on\n     * them.\n     *\n     * This list is immutable, but individual holders may revoke these via\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\n     */\n    function defaultOperators() external view returns (address[] memory);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n     * be an operator of `sender`.\n     *\n     * If send or receive hooks are registered for `sender` and `recipient`,\n     * the corresponding functions will be called with `data` and\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits a {Sent} event.\n     *\n     * Requirements\n     *\n     * - `sender` cannot be the zero address.\n     * - `sender` must have at least `amount` tokens.\n     * - the caller must be an operator for `sender`.\n     * - `recipient` cannot be the zero address.\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n     * The caller must be an operator of `account`.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n     *\n     * Emits a {Burned} event.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     * - the caller must be an operator for `account`.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external;\n\n    event Sent(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        bytes data,\n        bytes operatorData\n    );\n\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/ERC777.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/ERC777.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC777.sol\";\nimport \"./IERC777Recipient.sol\";\nimport \"./IERC777Sender.sol\";\nimport \"../ERC20/IERC20.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/IERC1820Registry.sol\";\n\n/**\n * @dev Implementation of the {IERC777} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * Support for ERC20 is included in this contract, as specified by the EIP: both\n * the ERC777 and ERC20 interfaces can be safely used when interacting with it.\n * Both {IERC777-Sent} and {IERC20-Transfer} events are emitted on token\n * movements.\n *\n * Additionally, the {IERC777-granularity} value is hard-coded to `1`, meaning that there\n * are no special restrictions in the amount of tokens that created, moved, or\n * destroyed. This makes integration with ERC20 applications seamless.\n */\ncontract ERC777 is Context, IERC777, IERC20 {\n    using Address for address;\n\n    IERC1820Registry internal constant _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n\n    mapping(address => uint256) private _balances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH = keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256(\"ERC777TokensRecipient\");\n\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\n    address[] private _defaultOperatorsArray;\n\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\n    mapping(address => bool) private _defaultOperators;\n\n    // For each account, a mapping of its operators and revoked default operators.\n    mapping(address => mapping(address => bool)) private _operators;\n    mapping(address => mapping(address => bool)) private _revokedDefaultOperators;\n\n    // ERC20-allowances\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    /**\n     * @dev `defaultOperators` may be an empty array.\n     */\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        address[] memory defaultOperators_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n\n        _defaultOperatorsArray = defaultOperators_;\n        for (uint256 i = 0; i < defaultOperators_.length; i++) {\n            _defaultOperators[defaultOperators_[i]] = true;\n        }\n\n        // register interfaces\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC777Token\"), address(this));\n        _ERC1820_REGISTRY.setInterfaceImplementer(address(this), keccak256(\"ERC20Token\"), address(this));\n    }\n\n    /**\n     * @dev See {IERC777-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC777-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {ERC20-decimals}.\n     *\n     * Always returns 18, as per the\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\n     */\n    function decimals() public pure virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC777-granularity}.\n     *\n     * This implementation always returns `1`.\n     */\n    function granularity() public view virtual override returns (uint256) {\n        return 1;\n    }\n\n    /**\n     * @dev See {IERC777-totalSupply}.\n     */\n    function totalSupply() public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\n     */\n    function balanceOf(address tokenHolder) public view virtual override(IERC20, IERC777) returns (uint256) {\n        return _balances[tokenHolder];\n    }\n\n    /**\n     * @dev See {IERC777-send}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function send(\n        address recipient,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\n     * interface if it is a contract.\n     *\n     * Also emits a {Sent} event.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n\n        address from = _msgSender();\n\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\n\n        _move(from, from, recipient, amount, \"\", \"\");\n\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev See {IERC777-burn}.\n     *\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\n     */\n    function burn(uint256 amount, bytes memory data) public virtual override {\n        _burn(_msgSender(), amount, data, \"\");\n    }\n\n    /**\n     * @dev See {IERC777-isOperatorFor}.\n     */\n    function isOperatorFor(address operator, address tokenHolder) public view virtual override returns (bool) {\n        return\n            operator == tokenHolder ||\n            (_defaultOperators[operator] && !_revokedDefaultOperators[tokenHolder][operator]) ||\n            _operators[tokenHolder][operator];\n    }\n\n    /**\n     * @dev See {IERC777-authorizeOperator}.\n     */\n    function authorizeOperator(address operator) public virtual override {\n        require(_msgSender() != operator, \"ERC777: authorizing self as operator\");\n\n        if (_defaultOperators[operator]) {\n            delete _revokedDefaultOperators[_msgSender()][operator];\n        } else {\n            _operators[_msgSender()][operator] = true;\n        }\n\n        emit AuthorizedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-revokeOperator}.\n     */\n    function revokeOperator(address operator) public virtual override {\n        require(operator != _msgSender(), \"ERC777: revoking self as operator\");\n\n        if (_defaultOperators[operator]) {\n            _revokedDefaultOperators[_msgSender()][operator] = true;\n        } else {\n            delete _operators[_msgSender()][operator];\n        }\n\n        emit RevokedOperator(operator, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC777-defaultOperators}.\n     */\n    function defaultOperators() public view virtual override returns (address[] memory) {\n        return _defaultOperatorsArray;\n    }\n\n    /**\n     * @dev See {IERC777-operatorSend}.\n     *\n     * Emits {Sent} and {IERC20-Transfer} events.\n     */\n    function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }\n\n    /**\n     * @dev See {IERC777-operatorBurn}.\n     *\n     * Emits {Burned} and {IERC20-Transfer} events.\n     */\n    function operatorBurn(\n        address account,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) public virtual override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators may\n     * not have allowance, and accounts with allowance may not be operators\n     * themselves.\n     */\n    function allowance(address holder, address spender) public view virtual override returns (uint256) {\n        return _allowances[holder][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function approve(address spender, uint256 value) public virtual override returns (bool) {\n        address holder = _msgSender();\n        _approve(holder, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Note that operator and allowance concepts are orthogonal: operators cannot\n     * call `transferFrom` (unless they have allowance), and accounts with\n     * allowance cannot call `operatorSend` (unless they are operators).\n     *\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\n     */\n    function transferFrom(\n        address holder,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\n\n        address spender = _msgSender();\n\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\n\n        _move(spender, holder, recipient, amount, \"\", \"\");\n\n        uint256 currentAllowance = _allowances[holder][spender];\n        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");\n        _approve(holder, spender, currentAllowance - amount);\n\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\n\n        return true;\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If a send hook is registered for `account`, the corresponding function\n     * will be called with `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) internal virtual {\n        _mint(account, amount, userData, operatorData, true);\n    }\n\n    /**\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * If `requireReceptionAck` is set to true, and if a send hook is\n     * registered for `account`, the corresponding function will be called with\n     * `operator`, `data` and `operatorData`.\n     *\n     * See {IERC777Sender} and {IERC777Recipient}.\n     *\n     * Emits {Minted} and {IERC20-Transfer} events.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\n     * interface.\n     */\n    function _mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(account != address(0), \"ERC777: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), account, amount);\n\n        // Update state variables\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\n\n        emit Minted(operator, account, amount, userData, operatorData);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Send tokens\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _send(\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) internal virtual {\n        require(from != address(0), \"ERC777: send from the zero address\");\n        require(to != address(0), \"ERC777: send to the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\n\n        _move(operator, from, to, amount, userData, operatorData);\n\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\n    }\n\n    /**\n     * @dev Burn tokens\n     * @param from address token holder address\n     * @param amount uint256 amount of tokens to burn\n     * @param data bytes extra information provided by the token holder\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    ) internal virtual {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _move(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        _beforeTokenTransfer(operator, from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Sent(operator, from, to, amount, userData, operatorData);\n        emit Transfer(from, to, amount);\n    }\n\n    /**\n     * @dev See {ERC20-_approve}.\n     *\n     * Note that accounts cannot have allowance issued by their operators.\n     */\n    function _approve(\n        address holder,\n        address spender,\n        uint256 value\n    ) internal {\n        require(holder != address(0), \"ERC777: approve from the zero address\");\n        require(spender != address(0), \"ERC777: approve to the zero address\");\n\n        _allowances[holder][spender] = value;\n        emit Approval(holder, spender, value);\n    }\n\n    /**\n     * @dev Call from.tokensToSend() if the interface is registered\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     */\n    function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }\n\n    /**\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\n     * tokensReceived() was not registered for the recipient\n     * @param operator address operator requesting the transfer\n     * @param from address token holder address\n     * @param to address recipient address\n     * @param amount uint256 amount of tokens to transfer\n     * @param userData bytes extra information provided by the token holder (if any)\n     * @param operatorData bytes extra information provided by the operator (if any)\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\n     */\n    function _callTokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData,\n        bool requireReceptionAck\n    ) private {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(to, _TOKENS_RECIPIENT_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\n        } else if (requireReceptionAck) {\n            require(!to.isContract(), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Sender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Sender.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\n *\n * {IERC777} Token holders can be notified of operations performed on their\n * tokens by having a contract implement this interface (contract holders can be\n * their own implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Sender {\n    /**\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\n     * is conveyed by `to` being the zero address or not.\n     *\n     * This call occurs _before_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/tokens/RAIR Token Facets/ERC721Facet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11;\r\nimport './AppStorage.sol';\r\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\r\nimport '@openzeppelin/contracts/utils/Address.sol';\r\n\r\ncontract ERC721Facet is AccessControlAppStorageEnumerable721 {\r\n\tusing Address for address;\r\n\r\n\tbytes32 public constant TRADER = keccak256(\"TRADER\");\r\n\tbytes32 public constant MINTER = keccak256(\"MINTER\");\r\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\r\n\r\n\tevent ProductCompleted(uint indexed productIndex);\r\n\tevent RangeCompleted(uint indexed rangeIndex, uint productIndex);\r\n\t\r\n\tevent TradingUnlocked(uint indexed rangeIndex, uint from, uint to);\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\t\r\n\tfunction name() public view returns (string memory) {\r\n\t\treturn s._name;\r\n\t}\r\n\r\n\tfunction symbol() public view returns (string memory) {\r\n\t\treturn s._symbol;\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) public view returns (uint256) {\r\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\t\treturn s._balances[owner];\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n\t\trequire(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n\t\treturn s._ownedTokens[owner][index];\r\n\t}\r\n\r\n\tfunction totalSupply() public view returns (uint256) {\r\n\t\treturn s._allTokens.length;\r\n\t}\r\n\r\n\tfunction tokenByIndex(uint256 index) public view returns (uint256) {\r\n\t\trequire(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n\t\treturn s._allTokens[index];\r\n\t}\r\n\r\n\t/// @notice Queries if an operator can act on behalf of an owner on all of their tokens\r\n\t/// @dev Overrides the OpenZeppelin standard by allowing anyone with the TRADER role to transfer tokens\r\n\t/// @param owner \t\tOwner of the tokens.\r\n\t/// @param operator \tOperator of the tokens.\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\r\n\t\treturn (hasRole(TRADER, operator) || s._operatorApprovals[owner][operator]);\r\n\t}\r\n\r\n\tfunction nextMintableTokenInRange(uint rangeIndex) public view returns (uint) {\r\n\t\trequire(s.ranges.length > rangeIndex, \"RAIR ERC721 Ranges: Range does not exist\");\r\n\t\trange memory selectedRange = s.ranges[rangeIndex];\r\n\t\tproduct memory selectedProduct = s.products[s.rangeToProduct[rangeIndex]];\r\n\t\tfor (uint i = selectedRange.rangeStart; i < selectedRange.rangeEnd; i++) {\r\n\t\t\tif (!_exists(selectedProduct.startingToken + i)) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(false, 'RAIR ERC721: There are no tokens available for minting');\r\n\t}\r\n\r\n\tfunction _mintFromRange(address to, uint rangeId, uint indexInRange) internal {\r\n\t\trequire(s.ranges.length > rangeId, \"RAIR ERC721: Range does not exist\");\r\n\t\trange storage selectedRange = s.ranges[rangeId];\r\n\t\tproduct storage selectedProduct = s.products[s.rangeToProduct[rangeId]];\r\n\t\trequire(selectedProduct.mintableTokens > 0, 'RAIR ERC721: Cannot mint more tokens from this product!');\r\n\t\trequire(selectedRange.mintableTokens > 0, 'RAIR ERC721: Cannot mint more tokens from this range!');\r\n\t\trequire(selectedRange.tokensAllowed > 0, 'RAIR ERC721: Not allowed to mint more tokens from this range!');\r\n\t\trequire(indexInRange >= selectedRange.rangeStart && indexInRange <= selectedRange.rangeEnd, \"RAIR ERC721: Invalid token index\");\r\n\t\t_safeMint(to, selectedProduct.startingToken + indexInRange, '');\r\n\t\t\r\n\t\tif (selectedRange.tokensAllowed > 0) {\r\n\t\t\tselectedRange.tokensAllowed--;\r\n\t\t}\r\n\t\tif (selectedRange.mintableTokens > 0) {\r\n\t\t\tselectedRange.mintableTokens--;\r\n\t\t\tif (selectedRange.mintableTokens == 0) {\r\n\t\t\t\temit RangeCompleted(rangeId, s.rangeToProduct[rangeId]);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (selectedRange.lockedTokens > 0) {\r\n\t\t\tselectedRange.lockedTokens--;\r\n\t\t\tif (selectedRange.lockedTokens == 0) {\r\n\t\t\t\temit TradingUnlocked(rangeId, selectedRange.rangeStart, selectedRange.rangeEnd);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (selectedProduct.mintableTokens > 0) {\r\n\t\t\tselectedProduct.mintableTokens--;\r\n\t\t\tif (selectedProduct.mintableTokens == 0) {\r\n\t\t\t\temit ProductCompleted(s.rangeToProduct[rangeId]);\r\n\t\t\t}\r\n\t\t}\r\n\t\ts.tokenToProduct[selectedProduct.startingToken + indexInRange] = s.rangeToProduct[rangeId];\r\n\t\ts.tokenToRange[selectedProduct.startingToken + indexInRange] = rangeId;\r\n\t\ts.tokensByProduct[s.rangeToProduct[rangeId]].push(selectedProduct.startingToken + indexInRange);\r\n\t}\r\n\r\n\tfunction mintFromRangeBatch(\r\n\t\taddress[] calldata to,\r\n\t\tuint rangeId,\r\n\t\tuint[] calldata indexInRange\r\n\t) external onlyRole(MINTER) {\r\n\t\trequire(to.length > 0, \"RAIR ERC721: Empty array\");\r\n\t\trequire(to.length == indexInRange.length, \"RAIR ERC721: Both arrays should have the same length\");\r\n\t\tfor (uint i = 0; i < to.length; i++) {\r\n\t\t\t_mintFromRange(to[i], rangeId, indexInRange[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mintFromRange(address to, uint rangeId, uint indexInRange) external onlyRole(MINTER) {\r\n\t\t_mintFromRange(to, rangeId, indexInRange);\r\n\t}\r\n\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\r\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n\t\taddress owner = ownerOf(tokenId);\r\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\tfunction approve(address to, uint256 tokenId) public {\r\n\t\taddress owner = ownerOf(tokenId);\r\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\r\n\r\n\t\trequire(\r\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\r\n\t\t);\r\n\r\n\t\t_approve(to, tokenId);\r\n\t}\r\n\r\n\tfunction setApprovalForAll(address operator, bool approved) public {\r\n\t\t_setApprovalForAll(_msgSender(), operator, approved);\r\n\t}\r\n\r\n\tfunction _setApprovalForAll(\r\n\t\taddress owner,\r\n\t\taddress operator,\r\n\t\tbool approved\r\n\t) internal virtual {\r\n\t\trequire(owner != operator, \"ERC721: approve to caller\");\r\n\t\ts._operatorApprovals[owner][operator] = approved;\r\n\t\temit ApprovalForAll(owner, operator, approved);\r\n\t}\r\n\r\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\r\n\t\ts._tokenApprovals[tokenId] = to;\r\n\t\temit Approval(ownerOf(tokenId), to, tokenId);\r\n\t}\r\n\r\n\tfunction getApproved(uint256 tokenId) public view returns (address) {\r\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\t\treturn s._tokenApprovals[tokenId];\r\n\t}\r\n\t\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n\t\treturn s._owners[tokenId] != address(0);\r\n\t}\r\n\r\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\r\n\t\t_safeMint(to, tokenId, \"\");\r\n\t}\r\n\r\n\tfunction _safeMint(\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) internal virtual {\r\n\t\t_mint(to, tokenId);\r\n\t\trequire(\r\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\r\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\r\n\t\t);\r\n\t}\r\n\r\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\r\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\r\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n\t\ts._balances[to] += 1;\r\n\t\ts._owners[tokenId] = to;\r\n\t\ts._minted[tokenId] = true;\r\n\r\n\t\temit Transfer(address(0), to, tokenId);\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenId) public view returns (address) {\r\n\t\taddress owner = s._owners[tokenId];\r\n\t\trequire(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n\t\treturn owner;\r\n\t}\r\n\r\n\t/// @notice Hook being called before every transfer\r\n\t/// @dev\tTransfer locking happens here!\r\n\t/// @param\t_from\t\tToken's original owner\r\n\t/// @param\t_to\t\t\tToken's new owner\r\n\t/// @param\t_tokenId\tToken's ID\r\n\tfunction _beforeTokenTransfer(address _from, address _to, uint256 _tokenId) internal {\r\n\t\t// If it's not minting or burning \r\n\t\tif (_from != address(0) && _to != address(0)) {\r\n\t\t\t_checkRole(TRADER, msg.sender);\r\n\t\t\trequire(s.ranges[s.tokenToRange[_tokenId]].lockedTokens == 0, \"RAIR ERC721: Cannot transfer from a locked range!\");\r\n\t\t}\r\n\t\tif (_from == address(0)) {\r\n\t\t\t_addTokenToAllTokensEnumeration(_tokenId);\r\n\t\t} else if (_from != _to) {\r\n\t\t\t_removeTokenFromOwnerEnumeration(_from, _tokenId);\r\n\t\t}\r\n\t\tif (_to == address(0)) {\r\n\t\t\t_removeTokenFromAllTokensEnumeration(_tokenId);\r\n\t\t} else if (_to != _from) {\r\n\t\t\t_addTokenToOwnerEnumeration(_to, _tokenId);\r\n\t\t}\r\n\t\t//require(hasRole(TRADER, _from), 'RAIR ERC721: Transfers cannot be made outside RAIR marketplaces!');\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n\t * @param to address representing the new owner of the given token ID\r\n\t * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n\t */\r\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n\t\tuint256 length = balanceOf(to);\r\n\t\ts._ownedTokens[to][length] = tokenId;\r\n\t\ts._ownedTokensIndex[tokenId] = length;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Private function to add a token to this extension's token tracking data structures.\r\n\t * @param tokenId uint256 ID of the token to be added to the tokens list\r\n\t */\r\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n\t\ts._allTokensIndex[tokenId] = s._allTokens.length;\r\n\t\ts._allTokens.push(tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n\t * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n\t * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n\t * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n\t * @param from address representing the previous owner of the given token ID\r\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n\t */\r\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n\t\t// To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n\t\t// then delete the last slot (swap and pop).\r\n\r\n\t\tuint256 lastTokenIndex = balanceOf(from) - 1;\r\n\t\tuint256 tokenIndex = s._ownedTokensIndex[tokenId];\r\n\r\n\t\t// When the token to delete is the last token, the swap operation is unnecessary\r\n\t\tif (tokenIndex != lastTokenIndex) {\r\n\t\t\tuint256 lastTokenId = s._ownedTokens[from][lastTokenIndex];\r\n\r\n\t\t\ts._ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n\t\t\ts._ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\t\t}\r\n\r\n\t\t// This also deletes the contents at the last position of the array\r\n\t\tdelete s._ownedTokensIndex[tokenId];\r\n\t\tdelete s._ownedTokens[from][lastTokenIndex];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Private function to remove a token from this extension's token tracking data structures.\r\n\t * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n\t */\r\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n\t\t// To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n\t\t// then delete the last slot (swap and pop).\r\n\r\n\t\tuint256 lastTokenIndex = s._allTokens.length - 1;\r\n\t\tuint256 tokenIndex = s._allTokensIndex[tokenId];\r\n\r\n\t\t// When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n\t\t// rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n\t\t// an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n\t\tuint256 lastTokenId = s._allTokens[lastTokenIndex];\r\n\r\n\t\ts._allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n\t\ts._allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n\t\t// This also deletes the contents at the last position of the array\r\n\t\tdelete s._allTokensIndex[tokenId];\r\n\t\ts._allTokens.pop();\r\n\t}\r\n\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) public {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-safeTransferFrom}.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) public {\r\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-safeTransferFrom}.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) public {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\t\t_safeTransfer(from, to, tokenId, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n\t *\r\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n\t *\r\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _safeTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) internal {\r\n\t\t_transfer(from, to, tokenId);\r\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers `tokenId` from `from` to `to`.\r\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must be owned by `from`.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) internal {\r\n\t\trequire(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(from, to, tokenId);\r\n\r\n\t\t// Clear approvals from the previous owner\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\ts._balances[from] -= 1;\r\n\t\ts._balances[to] += 1;\r\n\t\ts._owners[tokenId] = to;\r\n\r\n\t\temit Transfer(from, to, tokenId);\r\n\t}\r\n\r\n\tfunction _checkOnERC721Received(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) private returns (bool) {\r\n\t\tif (to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif (reason.length == 0) {\r\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n}"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/Factory/facets/ERC777ReceiverFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport \"@openzeppelin/contracts/token/ERC777/IERC777.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\r\nimport '../AppStorage.sol';\r\nimport '../../tokens/RAIR-ERC721-Diamond.sol';\r\n\r\ncontract ERC777ReceiverFacet is IERC777Recipient, AccessControlAppStorageEnumerable {\r\n\tbytes32 constant ERC777 = keccak256(\"ERC777\");\r\n\tbytes32 constant OWNER = keccak256(\"OWNER\");\r\n\t\r\n\tevent NewContractDeployed(address owner, uint id, address token, string contractName);\r\n\t\r\n\t/// @notice Function called by an ERC777 when they send tokens\r\n\t/// @dev    This is our deployment mechanism for ERC721 contracts!\r\n\t/// @param operator\t\tThe ERC777 operator calling the send() function\r\n\t/// @param from\t\t\tThe owner of the tokens\r\n\t/// @param to\t\t\tThe recipient of the tokens\r\n\t/// @param amount\t\tThe number of tokens sent\r\n\t/// @param userData\t\tbytes sent from the send call\r\n\t/// @param operatorData\tbytes sent from the operator\r\n\tfunction tokensReceived(address operator, address from, address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external onlyRole(ERC777) override {\r\n\t\tAppStorage storage s = LibAppStorage.diamondStorage();\r\n\t\trequire(amount >= s.deploymentCostForToken[msg.sender], 'RAIR Factory: not enough RAIR tokens to deploy a contract');\r\n\r\n\t\tif (amount - (s.deploymentCostForToken[msg.sender]) > 0) {\r\n\t\t\tIERC777(msg.sender).send(from, amount - (s.deploymentCostForToken[msg.sender]), bytes(\"RAIR\"));\r\n\t\t}\r\n\t\taddress[] storage deploymentsFromOwner = s.creatorToContracts[from];\r\n\t\t\r\n\t\tif (deploymentsFromOwner.length == 0) {\r\n\t\t\ts.creators.push(from);\r\n\t\t}\r\n\r\n\t\tRAIR_ERC721_Diamond newToken = new RAIR_ERC721_Diamond(string(userData), from, 30000);\r\n\t\tdeploymentsFromOwner.push(address(newToken));\r\n\t\ts.contractToCreator[address(newToken)] = from;\r\n\t\temit NewContractDeployed(from, deploymentsFromOwner.length, address(newToken), string(userData));\r\n\t}\r\n}"
    },
    "contracts/tokens/RAIR-ERC721-Diamond.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\n// Interfaces\r\n//import \"@openzeppelin/contracts/utils/introspection/IERC1820Registry.sol\";\r\nimport \"../diamondStandard/interfaces/IDiamondLoupe.sol\";\r\n\r\nimport './RAIR Token Facets/AppStorage.sol';\r\n\r\ncontract RAIR_ERC721_Diamond is AccessControlAppStorageEnumerable721 {\r\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\r\n\tbytes32 public constant MINTER = keccak256(\"MINTER\");\r\n\tbytes32 public constant TRADER = keccak256(\"TRADER\");\r\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n\t */\r\n\tconstructor(string memory name_, address creatorAddress_, uint16 creatorRoyalty_) {\r\n\t\ts._name = name_;\r\n\t\ts._symbol = \"RAIR\";\r\n\t\t\r\n\t\ts.factoryAddress = msg.sender;\r\n\t\ts.royaltyFee = creatorRoyalty_;\r\n\t\t_setRoleAdmin(MINTER, CREATOR);\r\n\t\t_setRoleAdmin(TRADER, CREATOR);\r\n\t\t_grantRole(CREATOR, creatorAddress_);\r\n\t\t_grantRole(MINTER, creatorAddress_);\r\n\t\t_grantRole(TRADER, creatorAddress_);\r\n\t}\r\n\r\n\tfunction getFactoryAddress() public view returns (address) {\r\n\t\treturn s.factoryAddress;\r\n\t}\r\n\r\n\tfallback() external {\r\n\t\taddress facet = IDiamondLoupe(s.factoryAddress).facetAddress(msg.sig);\r\n\t\tassembly {\r\n\t\t\t// copy function selector and any arguments\r\n\t\t\tcalldatacopy(0, 0, calldatasize())\r\n\t\t\t// execute function call using the facet\r\n\t\t\tlet result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n\t\t\t// get any return value\r\n\t\t\treturndatacopy(0, 0, returndatasize())\r\n\t\t\t// return any return value or error back to the caller\r\n\t\t\tswitch result\r\n\t\t\t\tcase 0 {\r\n\t\t\t\t\trevert(0, returndatasize())\r\n\t\t\t\t}\r\n\t\t\t\tdefault {\r\n\t\t\t\t\treturn(0, returndatasize())\r\n\t\t\t\t}\r\n\t\t}\r\n\t}\r\n}"
    },
    "contracts/diamondStandard/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "contracts/diamondStandard/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\r\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\r\n\r\n// It is exapected that this contract is customized if you want to deploy your diamond\r\n// with data from a deployment script. Use the init function to initialize state variables\r\n// of your diamond. Add parameters to the init funciton if you need to.\r\n\r\ncontract DiamondInit {    \r\n\r\n    // You can add parameters to this function in order to pass in \r\n    // data to set your own state variables\r\n    function init() external {\r\n        // adding ERC165 data\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n\r\n        // add your own state variables \r\n        // EIP-2535 specifies that the `diamondCut` function takes two optional \r\n        // arguments: address _init and bytes calldata _calldata\r\n        // These arguments are used to execute an arbitrary function using delegatecall\r\n        // in order to set state variables in the diamond during deployment or an upgrade\r\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \r\n    }\r\n\r\n\r\n}"
    },
    "contracts/diamondStandard/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n"
    },
    "contracts/diamondStandard/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n"
    },
    "contracts/diamondStandard/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\nimport { LibDiamond } from  \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\r\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external override view returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facets_ = new Facet[](ds.selectorCount);\r\n        uint8[] memory numFacetSelectors = new uint8[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\r\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facets_[numFacets].facetAddress = facetAddress_;\r\n                facets_[numFacets].functionSelectors = new bytes4[](ds.selectorCount);\r\n                facets_[numFacets].functionSelectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(facets_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\r\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory _facetFunctionSelectors) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numSelectors;\r\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(ds.facets[selector]));\r\n                if (_facet == facet) {\r\n                    _facetFunctionSelectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n        // Set the number of selectors in the array\r\n        assembly {\r\n            mstore(_facetFunctionSelectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = new address[](ds.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\r\n            bytes32 slot = ds.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > ds.selectorCount) {\r\n                    break;\r\n                }\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\r\n                bool continueLoop = false;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continueLoop = false;\r\n                    continue;\r\n                }\r\n                facetAddresses_[numFacets] = facetAddress_;\r\n                numFacets++;\r\n            }\r\n        }\r\n        // Set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(facetAddresses_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n"
    },
    "contracts/diamondStandard/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\r\n\r\ncontract OwnershipFacet is IERC173 {\r\n    function transferOwnership(address _newOwner) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    function owner() external override view returns (address owner_) {\r\n        owner_ = LibDiamond.contractOwner();\r\n    }\r\n}\r\n"
    },
    "contracts/diamondStandard/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        LibDiamond.initializeDiamondCut(_init, _calldata);\r\n    }\r\n}\r\n"
    },
    "contracts/tokens/forTest/RAIR-ERC777.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\r\n\r\ncontract RAIR777 is ERC777 {\r\n    constructor(uint256 initialSupply, address[] memory _defaultOperators )\r\n        ERC777(\"RAIR\", \"RAIR\", _defaultOperators)\r\n    {\r\n        _mint(msg.sender, initialSupply, \"\", \"\");\r\n    }\r\n\r\n    receive() external payable {}\r\n}"
    },
    "contracts/Factory/facets/creatorsFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport '../AppStorage.sol';\r\n\r\ncontract creatorFacet is AccessControlAppStorageEnumerable {\r\n\t/// @notice Returns the number of addresses that have deployed a contract\r\n\tfunction getCreatorsCount() public view returns(uint count) {\r\n\t\treturn s.creators.length;\r\n\t}\r\n\r\n\t/// @notice Returns a single address inside the creators array\r\n\tfunction getCreatorAtIndex(uint index) public view returns (address creator) {\r\n\t\tcreator = s.creators[index];\r\n\t}\r\n\r\n\t/// @notice Returns the number of contracts deployed by an address\r\n\t/// @dev\tUse alongside creatorToContracts for the full list of tokens \r\n\t/// @param\tdeployer\tWallet address to query\r\n\tfunction getContractCountOf(address deployer) public view returns(uint count) {\r\n\t\treturn s.creatorToContracts[deployer].length;\r\n\t}\r\n\r\n\t/// @notice Necessary view function now that public mappings are not possible\r\n\tfunction creatorToContractIndex(address deployer, uint index) public view returns(address deployedContract) {\r\n\t\treturn s.creatorToContracts[deployer][index];\r\n\t}\r\n\r\n\t/// @notice Returns the whole array of deployed addresses of a creator\r\n\tfunction creatorToContractList(address deployer) public view returns(address[] memory deployedContracts) {\r\n\t\treturn s.creatorToContracts[deployer];\r\n\t}\r\n\r\n\t/// @notice Returns the address of the creator given a deployed contract's address\r\n\tfunction contractToCreator(address deployedContract) public view returns (address creator) {\r\n\t\tcreator = s.contractToCreator[deployedContract];\r\n\t}\r\n}"
    },
    "contracts/Marketplace/Facets/MintingOffersFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\r\nimport '../AppStorage.sol';\r\n\r\ninterface IRAIR721 {\r\n\tstruct range {\r\n\t\tuint rangeStart;\r\n\t\tuint rangeEnd;\r\n\t\tuint tokensAllowed;\r\n\t\tuint mintableTokens;\r\n\t\tuint lockedTokens;\r\n\t\tuint rangePrice;\r\n\t\tstring rangeName;\r\n\t}\r\n\r\n\tfunction rangeInfo(uint rangeId) external view returns(range memory data);\r\n\tfunction mintFromRange(address to, uint rangeId, uint indexInRange) external;\r\n}\r\n\r\ncontract MintingOffersFacet is AccessControlAppStorageEnumerableMarket {\r\n\r\n\tevent AddedMintingOffer(address erc721Address, uint rangeIndex, string rangeName, uint price, uint feeSplitsLength, uint offerIndex);\r\n\tevent TokenMinted(address erc721Address, uint rangeIndex, uint tokenIndex, address buyer);\r\n\r\n\tmodifier checkCreatorRole(address erc721Address) {\r\n\t\trequire(IAccessControl(erc721Address).hasRole(bytes32(keccak256(\"CREATOR\")), address(msg.sender)), \"Minter Marketplace: Sender isn't the creator of the contract!\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier checkMinterRole(address erc721Address) {\r\n\t\trequire(hasMinterRole(erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier mintingOfferExists(uint rangeIndex_) {\r\n\t\trequire(s.mintingOffers.length > rangeIndex_, \"Minting Marketplace: Minting Offer doesn't exist\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier offerDoesntExist(address erc721Address, uint rangeIndex) {\r\n\t\trequire(s.addressToRangeOffer[erc721Address][rangeIndex] == 0, \"Minter Marketplace: Range already has an offer\");\r\n\t\tif (s.addressToRangeOffer[erc721Address][rangeIndex] == 0 && s.mintingOffers.length > 0) {\r\n\t\t\trequire(s.mintingOffers[0].erc721Address != erc721Address ||\r\n\t\t\t\t\t\ts.mintingOffers[0].rangeIndex != rangeIndex,\r\n\t\t\t\t\t\t\t\"Minter Marketplace: Range already has an offer\");\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction hasMinterRole(address erc721Address) internal view returns (bool) {\r\n\t\treturn IAccessControl(erc721Address).hasRole(bytes32(keccak256(\"MINTER\")), address(this));\r\n\t}\r\n\r\n\tfunction getOffersCountForAddress(address erc721Address) public view returns (uint) {\r\n\t\treturn s.addressToOffers[erc721Address].length;\r\n\t}\r\n\r\n\tfunction getOfferInfoForAddress(address erc721Address, uint rangeIndex) public view returns (mintingOffer memory mintOffer, IRAIR721.range memory rangeData) {\r\n\t\tmintingOffer memory selectedOffer = s.mintingOffers[s.addressToOffers[erc721Address][rangeIndex]];\r\n\t\treturn (selectedOffer, IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex));\r\n\t}\r\n\r\n\tfunction getOfferInfo(uint offerIndex) public view returns (mintingOffer memory mintOffer, IRAIR721.range memory rangeData) {\r\n\t\tmintingOffer memory selectedOffer = s.mintingOffers[offerIndex];\r\n\t\treturn (selectedOffer, IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex));\r\n\t}\r\n\r\n\tfunction addMintingOffer(\r\n\t\taddress erc721Address_,\r\n\t\tuint rangeIndex_,\r\n\t\tfeeSplits[] calldata splits,\r\n\t\tbool visible_,\r\n\t\taddress nodeAddress_\r\n\t) external {\r\n\t\t_addMintingOffer(erc721Address_, rangeIndex_, splits, visible_, nodeAddress_);\r\n\t}\r\n\r\n\tfunction addMintingOfferBatch(\r\n\t\taddress erc721Address_,\r\n\t\tuint[] calldata rangeIndexes,\r\n\t\tfeeSplits[] calldata splits,\r\n\t\tbool[] calldata visibility,\r\n\t\taddress nodeAddress_\r\n\t) external {\r\n\t\trequire(rangeIndexes.length == visibility.length, \"Minter Marketplace: Arrays should have the same length\");\r\n\t\tfor (uint i = 0; i < rangeIndexes.length; i++) {\r\n\t\t\t_addMintingOffer(erc721Address_, rangeIndexes[i], splits, visibility[i], nodeAddress_);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _addMintingOffer(\r\n\t\taddress erc721Address_,\r\n\t\tuint rangeIndex_,\r\n\t\tfeeSplits[] memory splits,\r\n\t\tbool visible_,\r\n\t\taddress nodeAddress_\r\n\t) internal checkCreatorRole(erc721Address_) checkMinterRole(erc721Address_) offerDoesntExist(erc721Address_, rangeIndex_) {\r\n\t\tmintingOffer storage newOffer = s.mintingOffers.push();\r\n\t\tIRAIR721.range memory rangeData = IRAIR721(erc721Address_).rangeInfo(rangeIndex_);\r\n\t\trequire(rangeData.mintableTokens > 0, \"Minter Marketplace: Offer doesn't have tokens available!\");\r\n\t\tnewOffer.erc721Address = erc721Address_;\r\n\t\tnewOffer.nodeAddress = nodeAddress_;\r\n\t\tnewOffer.rangeIndex = rangeIndex_;\r\n\t\tnewOffer.visible = visible_;\r\n\t\tuint totalPercentage = s.nodeFee + s.treasuryFee;\r\n\t\tfor (uint i = 0; i < splits.length; i++) {\r\n\t\t\ttotalPercentage += splits[i].percentage;\r\n\t\t\tnewOffer.fees.push(splits[i]);\r\n\t\t}\r\n\t\trequire(totalPercentage == (100 * s.decimalPow), \"Minter Marketplace: Fees don't add up to 100%\");\r\n\t\ts.addressToOffers[erc721Address_].push(s.mintingOffers.length - 1);\r\n\t\ts.addressToRangeOffer[erc721Address_][rangeIndex_] = s.mintingOffers.length - 1;\r\n\t\temit AddedMintingOffer(erc721Address_, rangeIndex_, rangeData.rangeName, rangeData.rangePrice, splits.length, s.mintingOffers.length - 1);\r\n\t}\r\n\r\n\tfunction buyMintingOffer(uint offerIndex_, uint tokenIndex_) public mintingOfferExists(offerIndex_) payable {\r\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[offerIndex_];\r\n\t\trequire(selectedOffer.visible, \"Minter Marketplace: This offer is not ready to be sold!\");\r\n\t\trequire(hasMinterRole(selectedOffer.erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\r\n\t\tIRAIR721.range memory rangeData = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\r\n\t\trequire(rangeData.rangePrice <= msg.value, \"Minter Marketplace: Insufficient funds!\");\r\n\t\tif (msg.value - rangeData.rangePrice > 0) {\r\n\t\t\tpayable(msg.sender).transfer(msg.value - rangeData.rangePrice);\r\n\t\t}\r\n\t\tuint totalTransferred = rangeData.rangePrice * (s.nodeFee + s.treasuryFee) / (100 * s.decimalPow);\r\n\t\tpayable(selectedOffer.nodeAddress).transfer(rangeData.rangePrice * s.nodeFee / (100 * s.decimalPow));\r\n\t\tpayable(s.treasuryAddress).transfer(rangeData.rangePrice * s.treasuryFee / (100 * s.decimalPow));\r\n\t\tuint auxMoneyToBeSent;\r\n\t\tfor (uint i = 0; i < selectedOffer.fees.length; i++) {\r\n\t\t\tauxMoneyToBeSent = rangeData.rangePrice * selectedOffer.fees[i].percentage / (100 * s.decimalPow);\r\n\t\t\ttotalTransferred += auxMoneyToBeSent;\r\n\t\t\tpayable(selectedOffer.fees[i].recipient).transfer(auxMoneyToBeSent);\r\n\t\t}\r\n\t\trequire(totalTransferred == rangeData.rangePrice, \"Minter Marketplace: Error transferring funds!\");\r\n\t\t_buyMintingOffer(selectedOffer.erc721Address, selectedOffer.rangeIndex, tokenIndex_);\r\n\t}\r\n\r\n\tfunction buyMintingOfferBatch(uint offerIndex_, uint[] calldata tokenIndexes) external mintingOfferExists(offerIndex_) payable {\r\n\t\tmintingOffer storage selectedOffer = s.mintingOffers[offerIndex_];\r\n\t\trequire(selectedOffer.visible, \"Minter Marketplace: This offer is not ready to be sold!\");\r\n\t\trequire(hasMinterRole(selectedOffer.erc721Address), \"Minter Marketplace: This Marketplace isn't a Minter!\");\r\n\t\tIRAIR721.range memory rangeData = IRAIR721(selectedOffer.erc721Address).rangeInfo(selectedOffer.rangeIndex);\r\n\t\trequire((rangeData.rangePrice * tokenIndexes.length) <= msg.value, \"Minter Marketplace: Insufficient funds!\");\r\n\t\tif (msg.value - (rangeData.rangePrice * tokenIndexes.length) > 0) {\r\n\t\t\tpayable(msg.sender).transfer(msg.value - (rangeData.rangePrice * tokenIndexes.length));\r\n\t\t}\r\n\t\tuint totalTransferred = (rangeData.rangePrice * tokenIndexes.length) * (s.nodeFee + s.treasuryFee) / (100 * s.decimalPow);\r\n\t\tpayable(selectedOffer.nodeAddress).transfer((rangeData.rangePrice * tokenIndexes.length) * s.nodeFee / (100 * s.decimalPow));\r\n\t\tpayable(s.treasuryAddress).transfer((rangeData.rangePrice * tokenIndexes.length) * s.treasuryFee / (100 * s.decimalPow));\r\n\t\tuint auxMoneyToBeSent;\r\n\t\tuint i;\r\n\t\tfor (i = 0; i < selectedOffer.fees.length; i++) {\r\n\t\t\tauxMoneyToBeSent = (rangeData.rangePrice * tokenIndexes.length) * selectedOffer.fees[i].percentage / (100 * s.decimalPow);\r\n\t\t\ttotalTransferred += auxMoneyToBeSent;\r\n\t\t\tpayable(selectedOffer.fees[i].recipient).transfer(auxMoneyToBeSent);\r\n\t\t}\r\n\t\trequire(totalTransferred == (rangeData.rangePrice * tokenIndexes.length), \"Minter Marketplace: Error transferring funds!\");\r\n\t\tfor (i = 0; i < tokenIndexes.length; i++) {\r\n\t\t\t_buyMintingOffer(selectedOffer.erc721Address, selectedOffer.rangeIndex, tokenIndexes[i]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction _buyMintingOffer(address erc721Address, uint rangeIndex, uint tokenIndex) internal {\r\n\t\tIRAIR721(erc721Address).mintFromRange(msg.sender, rangeIndex, tokenIndex);\r\n\t\temit TokenMinted(erc721Address, rangeIndex, tokenIndex, msg.sender);\r\n\t}\r\n}"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/Marketplace/Facets/FeesFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11; \r\n\r\nimport '@openzeppelin/contracts/access/IAccessControl.sol';\r\nimport '../AppStorage.sol';\r\n\r\ncontract FeesFacet is AccessControlAppStorageEnumerableMarket {\r\n\tbytes32 public constant MAINTAINER = keccak256(\"MAINTAINER\");\r\n\t\r\n\tevent UpdatedDecimals(uint decimals, uint precalculatedMultiplier);\r\n\tevent UpdatedNodeFee(uint decimals, uint newPercentage);\r\n\tevent UpdatedTreasuryFee(uint decimals, uint newPercentage);\r\n\tevent UpdatedTreasuryAddress(address newAddress);\r\n\r\n\tfunction getDecimals() public view returns (uint16) {\r\n\t\treturn s.decimals;\r\n\t}\r\n\r\n\tfunction updateDecimals(uint16 newDecimals_) public onlyRole(MAINTAINER) {\r\n\t\ts.decimals = newDecimals_;\r\n\t\ts.decimalPow = 10**newDecimals_;\r\n\t\temit UpdatedDecimals(s.decimals, s.decimalPow);\r\n\t}\r\n\r\n\tfunction getNodeFee() public view returns (uint16 decimals, uint nodeFee) {\r\n\t\treturn (s.decimals, s.nodeFee);\r\n\t}\r\n\r\n\tfunction updateNodeFee(uint newFee_) public onlyRole(MAINTAINER) {\r\n\t\trequire(newFee_ <= 100 * s.decimalPow, \"Marketplace: Invalid Fee!\");\r\n\t\ts.nodeFee = newFee_;\r\n\t\temit UpdatedNodeFee(s.decimals, newFee_);\r\n\t}\r\n\r\n\tfunction getTreasuryFee() public view returns (uint16 decimals, uint treasuryFee) {\r\n\t\treturn (s.decimals, s.treasuryFee);\r\n\t}\r\n\r\n\tfunction updateTreasuryFee(uint newFee_) public onlyRole(MAINTAINER) {\r\n\t\trequire(newFee_ <= 100 * s.decimalPow, \"Marketplace: Invalid Fee!\");\r\n\t\ts.treasuryFee = newFee_;\r\n\t\temit UpdatedTreasuryFee(s.decimals, newFee_);\r\n\t}\r\n\r\n\tfunction getTreasuryAddress() public view returns (address) {\r\n\t\treturn s.treasuryAddress;\r\n\t}\r\n\r\n\tfunction updateTreasuryAddress(address newAddress_) public onlyRole(MAINTAINER) {\r\n\t\ts.treasuryAddress = newAddress_;\r\n\t\temit UpdatedTreasuryAddress(newAddress_);\r\n\t}\r\n}"
    },
    "contracts/tokens/RAIR Token Facets/ProductFacet.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.11;\r\n\r\nimport './AppStorage.sol';\r\n\r\ncontract RAIRProductFacet is AccessControlAppStorageEnumerable721 {\r\n\tbytes32 public constant CREATOR = keccak256(\"CREATOR\");\r\n\tevent ProductCreated(uint indexed id, string name, uint startingToken, uint length);\r\n\r\n\t/// @notice\tMakes sure the product exists before doing changes to it\r\n\t/// @param\tproductID\tProduct to verify\r\n\tmodifier productExists(uint productID) {\r\n\t\trequire(s.products.length > productID, \"RAIR ERC721: Product does not exist\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier rangeExists(uint rangeID) {\r\n\t\trequire(s.ranges.length > rangeID, \"RAIR ERC721: Range does not exist\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier tokenExists(uint tokenIndex) {\r\n\t\trequire(s._minted[tokenIndex], \"RAIR ERC721: Query for nonexistent token\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction ownsTokenInProduct(address find, uint productIndex) public view productExists(productIndex) returns (bool) {\r\n\t\tproduct storage selectedProduct = s.products[productIndex];\r\n\t\treturn _ownsTokenInsideRange(find, selectedProduct.startingToken, selectedProduct.endingToken);\r\n\t}\r\n\r\n\tfunction ownsTokenInRange(address find, uint rangeIndex) public view rangeExists(rangeIndex) returns (bool) {\r\n\t\trange storage selectedRange = s.ranges[rangeIndex];\r\n\t\tuint startOfProduct = s.products[s.rangeToProduct[rangeIndex]].startingToken;\r\n\t\treturn _ownsTokenInsideRange(find, startOfProduct + selectedRange.rangeStart, startOfProduct + selectedRange.rangeEnd);\r\n\t}\r\n\r\n\tfunction _ownsTokenInsideRange(address find, uint from, uint to) internal view returns (bool) {\r\n\t\tfor (uint i = from; i < to; i++) {\r\n\t\t\tif (s._owners[i] == find) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction tokenByProduct(uint productIndex_, uint tokenIndex_) public view productExists(productIndex_) returns (uint) {\r\n\t\treturn s.tokensByProduct[productIndex_][tokenIndex_];\r\n\t}\r\n\r\n\tfunction productToToken(uint productIndex_, uint tokenIndex_) public view productExists(productIndex_) returns(uint) {\r\n\t\treturn s.products[productIndex_].startingToken + tokenIndex_;\r\n\t}\r\n\r\n\tfunction tokenToProductIndex(uint tokenIndex_) public view tokenExists(tokenIndex_) returns (uint) {\r\n\t\treturn tokenIndex_ - s.products[s.tokenToProduct[tokenIndex_]].startingToken;\r\n\t}\r\n\r\n\tfunction tokenToProduct(uint tokenIndex_) public view tokenExists(tokenIndex_) returns (uint productIndex, uint rangeIndex) {\r\n\t\tproductIndex = s.tokenToProduct[tokenIndex_];\r\n\t\trangeIndex = s.tokenToRange[tokenIndex_];\r\n\t}\r\n\r\n\t/// @notice\tReturns the number of products on the contract\r\n\t/// @dev\tUse with get product to list all of the products\r\n\tfunction getProductCount() external view returns(uint) {\r\n\t\treturn s.products.length;\r\n\t}\r\n\r\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\r\n\t\trequire(index < RAIRProductFacet.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n\t\treturn s._ownedTokens[owner][index];\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) public view returns (uint256) {\r\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\r\n\t\treturn s._balances[owner];\r\n\t}\r\n\r\n\tfunction _exists(uint256 tokenId) internal view returns (bool) {\r\n        return s._owners[tokenId] != address(0);\r\n    }\r\n\t\r\n\t/// @notice\tLoops through a range of tokens inside a product and returns the first token without an owner\r\n\t/// @dev\tUses a loop, do not call this from a non-view function!\r\n\t/// @param\tproductID\tIndex of the product to search\r\n\t/// @param\tstartingIndex\tIndex of the product to search\r\n\t/// @param\tendingIndex\t\tIndex of the product to search\r\n\tfunction getNextSequentialIndex(uint productID, uint startingIndex, uint endingIndex) public view productExists(productID) returns(uint nextIndex) {\r\n\t\tproduct memory currentProduct = s.products[productID];\r\n\t\tfor (uint i = currentProduct.startingToken + startingIndex; i <= currentProduct.startingToken + endingIndex; i++) {\r\n\t\t\tif (!_exists(i)) {\r\n\t\t\t\treturn i - currentProduct.startingToken;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(false, \"RAIR ERC721: There are no available tokens in this range.\");\r\n\t}\r\n\r\n\t/// @notice\tLoops over the user's tokens looking for one that belongs to a product and a specific range\r\n\t/// @dev\tLoops are expensive in solidity, so don't use this in a function that requires gas\r\n\t/// @param\tuserAddress\t\t\tUser to search\r\n\t/// @param\tproductIndex\t\tProduct to search\r\n\t/// @param\tstartingToken\t\tProduct to search\r\n\t/// @param\tendingToken\t\t\tProduct to search\r\n\tfunction hasTokenInProduct(\r\n\t\t\t\taddress userAddress,\r\n\t\t\t\tuint productIndex,\r\n\t\t\t\tuint startingToken,\r\n\t\t\t\tuint endingToken) public view returns (bool) {\r\n\t\tproduct memory aux = s.products[productIndex];\r\n\t\tif (aux.endingToken != 0) {\r\n\t\t\tfor (uint i = 0; i < balanceOf(userAddress); i++) {\r\n\t\t\t\tuint token = tokenOfOwnerByIndex(userAddress, i);\r\n\t\t\t\tif (s.tokenToProduct[token] == productIndex &&\r\n\t\t\t\t\t\ttoken >= aux.startingToken + startingToken &&\r\n\t\t\t\t\t\ttoken <= aux.startingToken + endingToken) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/// @notice\tReturns the number of tokens inside a product\r\n\t/// @param\tproductIndex \tProduct index\r\n\tfunction mintedTokensInProduct(uint productIndex) public view returns (uint length) {\r\n\t\tlength = s.tokensByProduct[productIndex].length;\r\n\t}\r\n\t\r\n\t/// @notice\tCreates a product\r\n\t/// @dev\tOnly a CREATOR can call this function\r\n\t/// @param\t_productName Name of the product\r\n\t/// @param\t_copies\t\t\tAmount of tokens inside the product\r\n\tfunction createProduct(string memory _productName, uint _copies) public onlyRole(CREATOR) {\r\n\t\tuint lastToken = s.products.length == 0 ? 0 : s.products[s.products.length - 1].endingToken + 1;\r\n\t\t\r\n\t\tproduct storage newProduct = s.products.push();\r\n\r\n\t\tnewProduct.startingToken = lastToken;\r\n\t\tnewProduct.endingToken = newProduct.startingToken + _copies - 1;\r\n\t\tnewProduct.name = string(_productName);\r\n\t\tnewProduct.mintableTokens = _copies;\r\n\t\t\r\n\t\temit ProductCreated(s.products.length - 1, _productName, lastToken, _copies);\r\n\t}\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}